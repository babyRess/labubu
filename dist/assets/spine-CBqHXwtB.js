var t=Object.defineProperty,e=(e,s,i)=>((e,s,i)=>s in e?t(e,s,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[s]=i)(e,"symbol"!=typeof s?s+"":s,i);import{T as s,L as i,E as a,e as r,c as n,p as o,a as l,b as h,D as c,R as d,G as u,B as m,d as f,S as g,f as p,g as b,h as x,r as w,i as y,j as k,k as v,l as A,m as S,n as I,C,V as M,o as F,q as Y,s as T,t as X,A as R,u as P}from"./pixi-CNGV2Pfe.js";if("undefined"!=typeof window&&window.PIXI){const t=window.require;window.require=e=>t?t(e):e.startsWith("@pixi/")||e.startsWith("pixi.js")?window.PIXI:void 0}class E{constructor(){e(this,"entries",{}),e(this,"size",0)}add(t){let e=this.entries[t];return this.entries[t]=!0,!e&&(this.size++,!0)}addAll(t){let e=this.size;for(var s=0,i=t.length;s<i;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const B=class t{constructor(t=0,s=0,i=0,a=0){e(this,"r"),e(this,"g"),e(this,"b"),e(this,"a"),this.r=t,this.g=s,this.b=i,this.a=a}set(t,e,s,i){return this.r=t,this.g=e,this.b=s,this.a=i,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t="#"==t.charAt(0)?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=8!=t.length?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,i){return this.r+=t,this.g+=e,this.b+=s,this.a+=i,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((4278190080&e)>>>24)/255,t.g=((16711680&e)>>>16)/255,t.b=((65280&e)>>>8)/255,t.a=(255&e)/255}static rgb888ToColor(t,e){t.r=((16711680&e)>>>16)/255,t.g=((65280&e)>>>8)/255,t.b=(255&e)/255}toRgb888(){const t=t=>("0"+(255*t).toString(16)).slice(-2);return Number("0x"+t(this.r)+t(this.g)+t(this.b))}static fromString(e,s=new t){return s.setFromString(e)}};e(B,"WHITE",new B(1,1,1,1)),e(B,"RED",new B(1,0,0,1)),e(B,"GREEN",new B(0,1,0,1)),e(B,"BLUE",new B(0,0,1,1)),e(B,"MAGENTA",new B(1,0,1,1));let V=B;const D=class t{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(e){return Math.cos(e*t.degRad)}static sinDeg(e){return Math.sin(e*t.degRad)}static atan2Deg(e,s){return Math.atan2(e,s)*t.degRad}static signum(t){return t>0?1:t<0?-1:0}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){let e=Math.pow(Math.abs(t),1/3);return t<0?-e:e}static randomTriangular(e,s){return t.randomTriangularWith(e,s,.5*(e+s))}static randomTriangularWith(t,e,s){let i=Math.random(),a=e-t;return i<=(s-t)/a?t+Math.sqrt(i*a*(s-t)):e-Math.sqrt((1-i)*a*(e-s))}static isPowerOfTwo(t){return t&&!(t&t-1)}};e(D,"PI",3.1415927),e(D,"PI2",2*D.PI),e(D,"invPI2",1/D.PI2),e(D,"radiansToDegrees",180/D.PI),e(D,"radDeg",D.radiansToDegrees),e(D,"degreesToRadians",D.PI/180),e(D,"degRad",D.degreesToRadians);let _=D;const N=class t{static arrayCopy(t,e,s,i,a){for(let r=e,n=i;r<e+a;r++,n++)s[n]=t[r]}static arrayFill(t,e,s,i){for(let a=e;a<s;a++)t[a]=i}static setArraySize(t,e,s=0){let i=t.length;if(i==e)return t;if(t.length=e,i<e)for(let a=i;a<e;a++)t[a]=s;return t}static ensureArrayCapacity(e,s,i=0){return e.length>=s?e:t.setArraySize(e,s,i)}static newArray(t,e){let s=new Array(t);for(let i=0;i<t;i++)s[i]=e;return s}static newFloatArray(e){if(t.SUPPORTS_TYPED_ARRAYS)return new Float32Array(e);{let t=new Array(e);for(let e=0;e<t.length;e++)t[e]=0;return t}}static newShortArray(e){if(t.SUPPORTS_TYPED_ARRAYS)return new Int16Array(e);{let t=new Array(e);for(let e=0;e<t.length;e++)t[e]=0;return t}}static toFloatArray(e){return t.SUPPORTS_TYPED_ARRAYS?new Float32Array(e):e}static toSinglePrecision(e){return t.SUPPORTS_TYPED_ARRAYS?Math.fround(e):e}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(var i=0;i<t.length;i++)if(t[i]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};e(N,"SUPPORTS_TYPED_ARRAYS","undefined"!=typeof Float32Array);let O=N;class L{constructor(t){e(this,"items",new Array),e(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}}class q{constructor(t=0,s=0){e(this,"x"),e(this,"y"),this.x=t,this.y=s}set(t,e){return this.x=t,this.y=e,this}length(){let t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){let t=this.length();return 0!=t&&(this.x/=t,this.y/=t),this}}class W{constructor(t){if(e(this,"name"),!t)throw new Error("name cannot be null.");this.name=t}}const U=class t extends W{constructor(s){super(s),e(this,"id",t.nextID++),e(this,"bones",null),e(this,"vertices",[]),e(this,"worldVerticesLength",0),e(this,"timelineAttachment",this)}computeWorldVertices(t,e,s,i,a,r){s=a+(s>>1)*r;let n=t.bone.skeleton,o=t.deform,l=this.vertices,h=this.bones;if(!h){o.length>0&&(l=o);let n=t.bone,h=n.worldX,c=n.worldY,d=n.a,u=n.b,m=n.c,f=n.d;for(let t=e,o=a;o<s;t+=2,o+=r){let e=l[t],s=l[t+1];i[o]=e*d+s*u+h,i[o+1]=e*m+s*f+c}return}let c=0,d=0;for(let m=0;m<e;m+=2){let t=h[c];c+=t+1,d+=t}let u=n.bones;if(0==o.length)for(let m=a,f=3*d;m<s;m+=r){let t=0,e=0,s=h[c++];for(s+=c;c<s;c++,f+=3){let s=u[h[c]],i=l[f],a=l[f+1],r=l[f+2];t+=(i*s.a+a*s.b+s.worldX)*r,e+=(i*s.c+a*s.d+s.worldY)*r}i[m]=t,i[m+1]=e}else{let t=o;for(let e=a,n=3*d,o=d<<1;e<s;e+=r){let s=0,a=0,r=h[c++];for(r+=c;c<r;c++,n+=3,o+=2){let e=u[h[c]],i=l[n]+t[o],r=l[n+1]+t[o+1],d=l[n+2];s+=(i*e.a+r*e.b+e.worldX)*d,a+=(i*e.c+r*e.d+e.worldY)*d}i[e]=s,i[e+1]=a}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),O.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=O.newFloatArray(this.vertices.length),O.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};e(U,"nextID",0);let z=U;const j=class t{constructor(s){e(this,"id",t.nextID()),e(this,"regions"),e(this,"start",0),e(this,"digits",0),e(this,"setupIndex",0),this.regions=new Array(s)}copy(){let e=new t(this.regions.length);return O.arrayCopy(this.regions,0,e.regions,0,this.regions.length),e.start=this.start,e.digits=this.digits,e.setupIndex=this.setupIndex,e}apply(t,e){let s=t.sequenceIndex;-1==s&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);let i=this.regions[s];e.region!=i&&(e.region=i,e.updateRegion())}getPath(t,e){let s=t,i=(this.start+e).toString();for(let a=this.digits-i.length;a>0;a--)s+="0";return s+=i,s}static nextID(){return t._nextID++}};e(j,"_nextID",0);let G=j;var $,H;(H=$||($={}))[H.hold=0]="hold",H[H.once=1]="once",H[H.loop=2]="loop",H[H.pingpong=3]="pingpong",H[H.onceReverse=4]="onceReverse",H[H.loopReverse=5]="loopReverse",H[H.pingpongReverse=6]="pingpongReverse";const K=[$.hold,$.once,$.loop,$.pingpong,$.onceReverse,$.loopReverse,$.pingpongReverse];class Q{constructor(t,s,i){if(e(this,"name"),e(this,"timelines",[]),e(this,"timelineIds",new E),e(this,"duration"),!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(s),this.duration=i}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(var e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,i,a,r,n,o){if(!t)throw new Error("skeleton cannot be null.");i&&0!=this.duration&&(s%=this.duration,e>0&&(e%=this.duration));let l=this.timelines;for(let h=0,c=l.length;h<c;h++)l[h].apply(t,e,s,a,r,n,o)}}var J,Z,tt,et;(Z=J||(J={}))[Z.setup=0]="setup",Z[Z.first=1]="first",Z[Z.replace=2]="replace",Z[Z.add=3]="add",(et=tt||(tt={}))[et.mixIn=0]="mixIn",et[et.mixOut=1]="mixOut";const st={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,inherit:7,rgb:8,alpha:9,rgb2:10,attachment:11,deform:12,event:13,drawOrder:14,ikConstraint:15,transformConstraint:16,pathConstraintPosition:17,pathConstraintSpacing:18,pathConstraintMix:19,physicsConstraintInertia:20,physicsConstraintStrength:21,physicsConstraintDamping:22,physicsConstraintMass:23,physicsConstraintWind:24,physicsConstraintGravity:25,physicsConstraintMix:26,physicsConstraintReset:27,sequence:28};class it{constructor(t,s){e(this,"propertyIds"),e(this,"frames"),this.propertyIds=s,this.frames=O.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){let s=t.length;for(let i=1;i<s;i++)if(t[i]>e)return i-1;return s-1}static search(t,e,s){let i=t.length;for(let a=s;a<i;a+=s)if(t[a]>e)return a-s;return i-s}}class at extends it{constructor(t,s,i){super(t,i),e(this,"curves"),this.curves=O.newFloatArray(t+18*s),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){let e=this.getFrameCount()+18*t;if(this.curves.length>e){let t=O.newFloatArray(e);O.arrayCopy(this.curves,0,t,0,e),this.curves=t}}setBezier(t,e,s,i,a,r,n,o,l,h,c){let d=this.curves,u=this.getFrameCount()+18*t;0==s&&(d[e]=2+u);let m=.03*(i-2*r+o),f=.03*(a-2*n+l),g=.006*(3*(r-o)-i+h),p=.006*(3*(n-l)-a+c),b=2*m+g,x=2*f+p,w=.3*(r-i)+m+.16666667*g,y=.3*(n-a)+f+.16666667*p,k=i+w,v=a+y;for(let A=u+18;u<A;u+=2)d[u]=k,d[u+1]=v,w+=b,y+=x,b+=g,x+=p,k+=w,v+=y}getBezierValue(t,e,s,i){let a=this.curves;if(a[i]>t){let r=this.frames[e],n=this.frames[e+s];return n+(t-r)/(a[i]-r)*(a[i+1]-n)}let r=i+18;for(i+=2;i<r;i+=2)if(a[i]>=t){let e=a[i-2],s=a[i-1];return s+(t-e)/(a[i]-e)*(a[i+1]-s)}e+=this.getFrameEntries();let n=a[r-2],o=a[r-1];return o+(t-n)/(this.frames[e]-n)*(this.frames[e+s]-o)}}class rt extends at{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){let e=this.frames,s=e.length-2;for(let a=2;a<=s;a+=2)if(e[a]>t){s=a-2;break}let i=this.curves[s>>1];switch(i){case 0:let i=e[s],a=e[s+1];return a+(t-i)/(e[s+2]-i)*(e[s+2+1]-a);case 1:return e[s+1]}return this.getBezierValue(t,s,1,i-2)}getRelativeValue(t,e,s,i,a){if(t<this.frames[0]){switch(s){case J.setup:return a;case J.first:return i+(a-i)*e}return i}let r=this.getCurveValue(t);switch(s){case J.setup:return a+r*e;case J.first:case J.replace:r+=a-i}return i+r*e}getAbsoluteValue(t,e,s,i,a){if(t<this.frames[0]){switch(s){case J.setup:return a;case J.first:return i+(a-i)*e}return i}let r=this.getCurveValue(t);return s==J.setup?a+(r-a)*e:i+(r-i)*e}getAbsoluteValue2(t,e,s,i,a,r){if(t<this.frames[0]){switch(s){case J.setup:return a;case J.first:return i+(a-i)*e}return i}return s==J.setup?a+(r-a)*e:i+(r-i)*e}getScaleValue(t,e,s,i,a,r){if(t<this.frames[0]){switch(s){case J.setup:return r;case J.first:return a+(r-a)*e}return a}let n=this.getCurveValue(t)*r;if(1==e)return s==J.add?a+n-r:n;if(i==tt.mixOut)switch(s){case J.setup:return r+(Math.abs(n)*_.signum(r)-r)*e;case J.first:case J.replace:return a+(Math.abs(n)*_.signum(a)-a)*e}else{let t=0;switch(s){case J.setup:return t=Math.abs(r)*_.signum(n),t+(n-t)*e;case J.first:case J.replace:return t=Math.abs(a)*_.signum(n),t+(n-t)*e}}return a+(n-r)*e}}class nt extends at{constructor(t,e,s,i){super(t,e,[s,i])}getFrameEntries(){return 3}setFrame(t,e,s,i){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=i}}class ot extends rt{constructor(t,s,i){super(t,s,st.rotate+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];o.active&&(o.rotation=this.getRelativeValue(s,a,r,o.rotation,o.data.rotation))}}class lt extends nt{constructor(t,s,i){super(t,s,st.x+"|"+i,st.y+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];if(!o.active)return;let l=this.frames;if(s<l[0]){switch(r){case J.setup:return o.x=o.data.x,void(o.y=o.data.y);case J.first:o.x+=(o.data.x-o.x)*a,o.y+=(o.data.y-o.y)*a}return}let h=0,c=0,d=it.search(l,s,3),u=this.curves[d/3];switch(u){case 0:let t=l[d];h=l[d+1],c=l[d+2];let e=(s-t)/(l[d+3]-t);h+=(l[d+3+1]-h)*e,c+=(l[d+3+2]-c)*e;break;case 1:h=l[d+1],c=l[d+2];break;default:h=this.getBezierValue(s,d,1,u-2),c=this.getBezierValue(s,d,2,u+18-2)}switch(r){case J.setup:o.x=o.data.x+h*a,o.y=o.data.y+c*a;break;case J.first:case J.replace:o.x+=(o.data.x+h-o.x)*a,o.y+=(o.data.y+c-o.y)*a;break;case J.add:o.x+=h*a,o.y+=c*a}}}class ht extends rt{constructor(t,s,i){super(t,s,st.x+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];o.active&&(o.x=this.getRelativeValue(s,a,r,o.x,o.data.x))}}class ct extends rt{constructor(t,s,i){super(t,s,st.y+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];o.active&&(o.y=this.getRelativeValue(s,a,r,o.y,o.data.y))}}class dt extends nt{constructor(t,s,i){super(t,s,st.scaleX+"|"+i,st.scaleY+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];if(!o.active)return;let l,h,c=this.frames;if(s<c[0]){switch(r){case J.setup:return o.scaleX=o.data.scaleX,void(o.scaleY=o.data.scaleY);case J.first:o.scaleX+=(o.data.scaleX-o.scaleX)*a,o.scaleY+=(o.data.scaleY-o.scaleY)*a}return}let d=it.search(c,s,3),u=this.curves[d/3];switch(u){case 0:let t=c[d];l=c[d+1],h=c[d+2];let e=(s-t)/(c[d+3]-t);l+=(c[d+3+1]-l)*e,h+=(c[d+3+2]-h)*e;break;case 1:l=c[d+1],h=c[d+2];break;default:l=this.getBezierValue(s,d,1,u-2),h=this.getBezierValue(s,d,2,u+18-2)}if(l*=o.data.scaleX,h*=o.data.scaleY,1==a)r==J.add?(o.scaleX+=l-o.data.scaleX,o.scaleY+=h-o.data.scaleY):(o.scaleX=l,o.scaleY=h);else{let t=0,e=0;if(n==tt.mixOut)switch(r){case J.setup:t=o.data.scaleX,e=o.data.scaleY,o.scaleX=t+(Math.abs(l)*_.signum(t)-t)*a,o.scaleY=e+(Math.abs(h)*_.signum(e)-e)*a;break;case J.first:case J.replace:t=o.scaleX,e=o.scaleY,o.scaleX=t+(Math.abs(l)*_.signum(t)-t)*a,o.scaleY=e+(Math.abs(h)*_.signum(e)-e)*a;break;case J.add:o.scaleX+=(l-o.data.scaleX)*a,o.scaleY+=(h-o.data.scaleY)*a}else switch(r){case J.setup:t=Math.abs(o.data.scaleX)*_.signum(l),e=Math.abs(o.data.scaleY)*_.signum(h),o.scaleX=t+(l-t)*a,o.scaleY=e+(h-e)*a;break;case J.first:case J.replace:t=Math.abs(o.scaleX)*_.signum(l),e=Math.abs(o.scaleY)*_.signum(h),o.scaleX=t+(l-t)*a,o.scaleY=e+(h-e)*a;break;case J.add:o.scaleX+=(l-o.data.scaleX)*a,o.scaleY+=(h-o.data.scaleY)*a}}}}class ut extends rt{constructor(t,s,i){super(t,s,st.scaleX+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];o.active&&(o.scaleX=this.getScaleValue(s,a,r,n,o.scaleX,o.data.scaleX))}}class mt extends rt{constructor(t,s,i){super(t,s,st.scaleY+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];o.active&&(o.scaleY=this.getScaleValue(s,a,r,n,o.scaleY,o.data.scaleY))}}class ft extends nt{constructor(t,s,i){super(t,s,st.shearX+"|"+i,st.shearY+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];if(!o.active)return;let l=this.frames;if(s<l[0]){switch(r){case J.setup:return o.shearX=o.data.shearX,void(o.shearY=o.data.shearY);case J.first:o.shearX+=(o.data.shearX-o.shearX)*a,o.shearY+=(o.data.shearY-o.shearY)*a}return}let h=0,c=0,d=it.search(l,s,3),u=this.curves[d/3];switch(u){case 0:let t=l[d];h=l[d+1],c=l[d+2];let e=(s-t)/(l[d+3]-t);h+=(l[d+3+1]-h)*e,c+=(l[d+3+2]-c)*e;break;case 1:h=l[d+1],c=l[d+2];break;default:h=this.getBezierValue(s,d,1,u-2),c=this.getBezierValue(s,d,2,u+18-2)}switch(r){case J.setup:o.shearX=o.data.shearX+h*a,o.shearY=o.data.shearY+c*a;break;case J.first:case J.replace:o.shearX+=(o.data.shearX+h-o.shearX)*a,o.shearY+=(o.data.shearY+c-o.shearY)*a;break;case J.add:o.shearX+=h*a,o.shearY+=c*a}}}class gt extends rt{constructor(t,s,i){super(t,s,st.shearX+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];o.active&&(o.shearX=this.getRelativeValue(s,a,r,o.shearX,o.data.shearX))}}class pt extends rt{constructor(t,s,i){super(t,s,st.shearY+"|"+i),e(this,"boneIndex",0),this.boneIndex=i}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];o.active&&(o.shearY=this.getRelativeValue(s,a,r,o.shearY,o.data.shearY))}}class bt extends it{constructor(t,s){super(t,[st.inherit+"|"+s]),e(this,"boneIndex",0),this.boneIndex=s}getFrameEntries(){return 2}setFrame(t,e,s){t*=2,this.frames[t]=e,this.frames[t+1]=s}apply(t,e,s,i,a,r,n){let o=t.bones[this.boneIndex];if(!o.active)return;if(n==tt.mixOut)return void(r==J.setup&&(o.inherit=o.data.inherit));let l=this.frames;s<l[0]?r!=J.setup&&r!=J.first||(o.inherit=o.data.inherit):o.inherit=this.frames[it.search(l,s,2)+1]}}class xt extends at{constructor(t,s,i){super(t,s,[st.rgb+"|"+i,st.alpha+"|"+i]),e(this,"slotIndex",0),this.slotIndex=i}getFrameEntries(){return 5}setFrame(t,e,s,i,a,r){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=r}apply(t,e,s,i,a,r,n){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let l=this.frames,h=o.color;if(s<l[0]){let t=o.data.color;switch(r){case J.setup:return void h.setFromColor(t);case J.first:h.add((t.r-h.r)*a,(t.g-h.g)*a,(t.b-h.b)*a,(t.a-h.a)*a)}return}let c=0,d=0,u=0,m=0,f=it.search(l,s,5),g=this.curves[f/5];switch(g){case 0:let t=l[f];c=l[f+1],d=l[f+2],u=l[f+3],m=l[f+4];let e=(s-t)/(l[f+5]-t);c+=(l[f+5+1]-c)*e,d+=(l[f+5+2]-d)*e,u+=(l[f+5+3]-u)*e,m+=(l[f+5+4]-m)*e;break;case 1:c=l[f+1],d=l[f+2],u=l[f+3],m=l[f+4];break;default:c=this.getBezierValue(s,f,1,g-2),d=this.getBezierValue(s,f,2,g+18-2),u=this.getBezierValue(s,f,3,g+36-2),m=this.getBezierValue(s,f,4,g+54-2)}1==a?h.set(c,d,u,m):(r==J.setup&&h.setFromColor(o.data.color),h.add((c-h.r)*a,(d-h.g)*a,(u-h.b)*a,(m-h.a)*a))}}class wt extends at{constructor(t,s,i){super(t,s,[st.rgb+"|"+i]),e(this,"slotIndex",0),this.slotIndex=i}getFrameEntries(){return 4}setFrame(t,e,s,i,a){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=a}apply(t,e,s,i,a,r,n){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let l=this.frames,h=o.color;if(s<l[0]){let t=o.data.color;switch(r){case J.setup:return h.r=t.r,h.g=t.g,void(h.b=t.b);case J.first:h.r+=(t.r-h.r)*a,h.g+=(t.g-h.g)*a,h.b+=(t.b-h.b)*a}return}let c=0,d=0,u=0,m=it.search(l,s,4),f=this.curves[m>>2];switch(f){case 0:let t=l[m];c=l[m+1],d=l[m+2],u=l[m+3];let e=(s-t)/(l[m+4]-t);c+=(l[m+4+1]-c)*e,d+=(l[m+4+2]-d)*e,u+=(l[m+4+3]-u)*e;break;case 1:c=l[m+1],d=l[m+2],u=l[m+3];break;default:c=this.getBezierValue(s,m,1,f-2),d=this.getBezierValue(s,m,2,f+18-2),u=this.getBezierValue(s,m,3,f+36-2)}if(1==a)h.r=c,h.g=d,h.b=u;else{if(r==J.setup){let t=o.data.color;h.r=t.r,h.g=t.g,h.b=t.b}h.r+=(c-h.r)*a,h.g+=(d-h.g)*a,h.b+=(u-h.b)*a}}}class yt extends rt{constructor(t,s,i){super(t,s,st.alpha+"|"+i),e(this,"slotIndex",0),this.slotIndex=i}apply(t,e,s,i,a,r,n){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let l=o.color;if(s<this.frames[0]){let t=o.data.color;switch(r){case J.setup:return void(l.a=t.a);case J.first:l.a+=(t.a-l.a)*a}return}let h=this.getCurveValue(s);1==a?l.a=h:(r==J.setup&&(l.a=o.data.color.a),l.a+=(h-l.a)*a)}}class kt extends at{constructor(t,s,i){super(t,s,[st.rgb+"|"+i,st.alpha+"|"+i,st.rgb2+"|"+i]),e(this,"slotIndex",0),this.slotIndex=i}getFrameEntries(){return 8}setFrame(t,e,s,i,a,r,n,o,l){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=r,this.frames[t+5]=n,this.frames[t+6]=o,this.frames[t+7]=l}apply(t,e,s,i,a,r,n){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let l=this.frames,h=o.color,c=o.darkColor;if(s<l[0]){let t=o.data.color,e=o.data.darkColor;switch(r){case J.setup:return h.setFromColor(t),c.r=e.r,c.g=e.g,void(c.b=e.b);case J.first:h.add((t.r-h.r)*a,(t.g-h.g)*a,(t.b-h.b)*a,(t.a-h.a)*a),c.r+=(e.r-c.r)*a,c.g+=(e.g-c.g)*a,c.b+=(e.b-c.b)*a}return}let d=0,u=0,m=0,f=0,g=0,p=0,b=0,x=it.search(l,s,8),w=this.curves[x>>3];switch(w){case 0:let t=l[x];d=l[x+1],u=l[x+2],m=l[x+3],f=l[x+4],g=l[x+5],p=l[x+6],b=l[x+7];let e=(s-t)/(l[x+8]-t);d+=(l[x+8+1]-d)*e,u+=(l[x+8+2]-u)*e,m+=(l[x+8+3]-m)*e,f+=(l[x+8+4]-f)*e,g+=(l[x+8+5]-g)*e,p+=(l[x+8+6]-p)*e,b+=(l[x+8+7]-b)*e;break;case 1:d=l[x+1],u=l[x+2],m=l[x+3],f=l[x+4],g=l[x+5],p=l[x+6],b=l[x+7];break;default:d=this.getBezierValue(s,x,1,w-2),u=this.getBezierValue(s,x,2,w+18-2),m=this.getBezierValue(s,x,3,w+36-2),f=this.getBezierValue(s,x,4,w+54-2),g=this.getBezierValue(s,x,5,w+72-2),p=this.getBezierValue(s,x,6,w+90-2),b=this.getBezierValue(s,x,7,w+108-2)}if(1==a)h.set(d,u,m,f),c.r=g,c.g=p,c.b=b;else{if(r==J.setup){h.setFromColor(o.data.color);let t=o.data.darkColor;c.r=t.r,c.g=t.g,c.b=t.b}h.add((d-h.r)*a,(u-h.g)*a,(m-h.b)*a,(f-h.a)*a),c.r+=(g-c.r)*a,c.g+=(p-c.g)*a,c.b+=(b-c.b)*a}}}class vt extends at{constructor(t,s,i){super(t,s,[st.rgb+"|"+i,st.rgb2+"|"+i]),e(this,"slotIndex",0),this.slotIndex=i}getFrameEntries(){return 7}setFrame(t,e,s,i,a,r,n,o){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=r,this.frames[t+5]=n,this.frames[t+6]=o}apply(t,e,s,i,a,r,n){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let l=this.frames,h=o.color,c=o.darkColor;if(s<l[0]){let t=o.data.color,e=o.data.darkColor;switch(r){case J.setup:return h.r=t.r,h.g=t.g,h.b=t.b,c.r=e.r,c.g=e.g,void(c.b=e.b);case J.first:h.r+=(t.r-h.r)*a,h.g+=(t.g-h.g)*a,h.b+=(t.b-h.b)*a,c.r+=(e.r-c.r)*a,c.g+=(e.g-c.g)*a,c.b+=(e.b-c.b)*a}return}let d=0,u=0,m=0,f=0,g=0,p=0,b=it.search(l,s,7),x=this.curves[b/7];switch(x){case 0:let t=l[b];d=l[b+1],u=l[b+2],m=l[b+3],f=l[b+4],g=l[b+5],p=l[b+6];let e=(s-t)/(l[b+7]-t);d+=(l[b+7+1]-d)*e,u+=(l[b+7+2]-u)*e,m+=(l[b+7+3]-m)*e,f+=(l[b+7+4]-f)*e,g+=(l[b+7+5]-g)*e,p+=(l[b+7+6]-p)*e;break;case 1:d=l[b+1],u=l[b+2],m=l[b+3],f=l[b+4],g=l[b+5],p=l[b+6];break;default:d=this.getBezierValue(s,b,1,x-2),u=this.getBezierValue(s,b,2,x+18-2),m=this.getBezierValue(s,b,3,x+36-2),f=this.getBezierValue(s,b,4,x+54-2),g=this.getBezierValue(s,b,5,x+72-2),p=this.getBezierValue(s,b,6,x+90-2)}if(1==a)h.r=d,h.g=u,h.b=m,c.r=f,c.g=g,c.b=p;else{if(r==J.setup){let t=o.data.color,e=o.data.darkColor;h.r=t.r,h.g=t.g,h.b=t.b,c.r=e.r,c.g=e.g,c.b=e.b}h.r+=(d-h.r)*a,h.g+=(u-h.g)*a,h.b+=(m-h.b)*a,c.r+=(f-c.r)*a,c.g+=(g-c.g)*a,c.b+=(p-c.b)*a}}}class At extends it{constructor(t,s){super(t,[st.attachment+"|"+s]),e(this,"slotIndex",0),e(this,"attachmentNames"),this.slotIndex=s,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,i,a,r,n){let o=t.slots[this.slotIndex];o.bone.active&&(n!=tt.mixOut?s<this.frames[0]?r!=J.setup&&r!=J.first||this.setAttachment(t,o,o.data.attachmentName):this.setAttachment(t,o,this.attachmentNames[it.search1(this.frames,s)]):r==J.setup&&this.setAttachment(t,o,o.data.attachmentName))}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}}class St extends at{constructor(t,s,i,a){super(t,s,[st.deform+"|"+i+"|"+a.id]),e(this,"slotIndex",0),e(this,"attachment"),e(this,"vertices"),this.slotIndex=i,this.attachment=a,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,i,a,r,n,o,l,h,c){let d=this.curves,u=this.getFrameCount()+18*t;0==s&&(d[e]=2+u);let m=.03*(i-2*r+o),f=.03*l-.06*n,g=.006*(3*(r-o)-i+h),p=.018*(n-l+.33333333),b=2*m+g,x=2*f+p,w=.3*(r-i)+m+.16666667*g,y=.3*n+f+.16666667*p,k=i+w,v=y;for(let A=u+18;u<A;u+=2)d[u]=k,d[u+1]=v,w+=b,y+=x,b+=g,x+=p,k+=w,v+=y}getCurvePercent(t,e){let s=this.curves,i=s[e];switch(i){case 0:let s=this.frames[e];return(t-s)/(this.frames[e+this.getFrameEntries()]-s);case 1:return 0}if(i-=2,s[i]>t){let a=this.frames[e];return s[i+1]*(t-a)/(s[i]-a)}let a=i+18;for(i+=2;i<a;i+=2)if(s[i]>=t){let e=s[i-2],a=s[i-1];return a+(t-e)/(s[i]-e)*(s[i+1]-a)}let r=s[a-2],n=s[a-1];return n+(1-n)*(t-r)/(this.frames[e+this.getFrameEntries()]-r)}apply(t,e,s,i,a,r,n){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let l=o.getAttachment();if(!l)return;if(!(l instanceof z)||l.timelineAttachment!=this.attachment)return;let h=o.deform;0==h.length&&(r=J.setup);let c=this.vertices,d=c[0].length,u=this.frames;if(s<u[0]){switch(r){case J.setup:return void(h.length=0);case J.first:if(1==a)return void(h.length=0);h.length=d;let t=l;if(t.bones){a=1-a;for(m=0;m<d;m++)h[m]*=a}else{let e=t.vertices;for(var m=0;m<d;m++)h[m]+=(e[m]-h[m])*a}}return}if(h.length=d,s>=u[u.length-1]){let t=c[u.length-1];if(1==a)if(r==J.add){let e=l;if(e.bones)for(let s=0;s<d;s++)h[s]+=t[s];else{let s=e.vertices;for(let e=0;e<d;e++)h[e]+=t[e]-s[e]}}else O.arrayCopy(t,0,h,0,d);else switch(r){case J.setup:{let e=l;if(e.bones)for(let s=0;s<d;s++)h[s]=t[s]*a;else{let s=e.vertices;for(let e=0;e<d;e++){let i=s[e];h[e]=i+(t[e]-i)*a}}break}case J.first:case J.replace:for(let s=0;s<d;s++)h[s]+=(t[s]-h[s])*a;break;case J.add:let e=l;if(e.bones)for(let s=0;s<d;s++)h[s]+=t[s]*a;else{let s=e.vertices;for(let e=0;e<d;e++)h[e]+=(t[e]-s[e])*a}}return}let f=it.search1(u,s),g=this.getCurvePercent(s,f),p=c[f],b=c[f+1];if(1==a)if(r==J.add){let t=l;if(t.bones)for(let e=0;e<d;e++){let t=p[e];h[e]+=t+(b[e]-t)*g}else{let e=t.vertices;for(let t=0;t<d;t++){let s=p[t];h[t]+=s+(b[t]-s)*g-e[t]}}}else for(let x=0;x<d;x++){let t=p[x];h[x]=t+(b[x]-t)*g}else switch(r){case J.setup:{let t=l;if(t.bones)for(let e=0;e<d;e++){let t=p[e];h[e]=(t+(b[e]-t)*g)*a}else{let e=t.vertices;for(let t=0;t<d;t++){let s=p[t],i=e[t];h[t]=i+(s+(b[t]-s)*g-i)*a}}break}case J.first:case J.replace:for(let e=0;e<d;e++){let t=p[e];h[e]+=(t+(b[e]-t)*g-h[e])*a}break;case J.add:let t=l;if(t.bones)for(let e=0;e<d;e++){let t=p[e];h[e]+=(t+(b[e]-t)*g)*a}else{let e=t.vertices;for(let t=0;t<d;t++){let s=p[t];h[t]+=(s+(b[t]-s)*g-e[t])*a}}}}}const It=class t extends it{constructor(s){super(s,t.propertyIds),e(this,"events"),this.events=new Array(s)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,i,a,r,n){if(!i)return;let o=this.frames,l=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,i,a,r,n),e=-1;else if(e>=o[l-1])return;if(s<o[0])return;let h=0;if(e<o[0])h=0;else{h=it.search1(o,e)+1;let t=o[h];for(;h>0&&o[h-1]==t;)h--}for(;h<l&&s>=o[h];h++)i.push(this.events[h])}};e(It,"propertyIds",[""+st.event]);let Ct=It;const Mt=class t extends it{constructor(s){super(s,t.propertyIds),e(this,"drawOrders"),this.drawOrders=new Array(s)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,i,a,r,n){if(n==tt.mixOut)return void(r==J.setup&&O.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));if(s<this.frames[0])return void(r!=J.setup&&r!=J.first||O.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));let o=it.search1(this.frames,s),l=this.drawOrders[o];if(l){let e=t.drawOrder,s=t.slots;for(let t=0,i=l.length;t<i;t++)e[t]=s[l[t]]}else O.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length)}};e(Mt,"propertyIds",[""+st.drawOrder]);let Ft=Mt;class Yt extends at{constructor(t,s,i){super(t,s,[st.ikConstraint+"|"+i]),e(this,"constraintIndex",0),this.constraintIndex=i}getFrameEntries(){return 6}setFrame(t,e,s,i,a,r,n){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=r?1:0,this.frames[t+5]=n?1:0}apply(t,e,s,i,a,r,n){let o=t.ikConstraints[this.constraintIndex];if(!o.active)return;let l=this.frames;if(s<l[0]){switch(r){case J.setup:return o.mix=o.data.mix,o.softness=o.data.softness,o.bendDirection=o.data.bendDirection,o.compress=o.data.compress,void(o.stretch=o.data.stretch);case J.first:o.mix+=(o.data.mix-o.mix)*a,o.softness+=(o.data.softness-o.softness)*a,o.bendDirection=o.data.bendDirection,o.compress=o.data.compress,o.stretch=o.data.stretch}return}let h=0,c=0,d=it.search(l,s,6),u=this.curves[d/6];switch(u){case 0:let t=l[d];h=l[d+1],c=l[d+2];let e=(s-t)/(l[d+6]-t);h+=(l[d+6+1]-h)*e,c+=(l[d+6+2]-c)*e;break;case 1:h=l[d+1],c=l[d+2];break;default:h=this.getBezierValue(s,d,1,u-2),c=this.getBezierValue(s,d,2,u+18-2)}r==J.setup?(o.mix=o.data.mix+(h-o.data.mix)*a,o.softness=o.data.softness+(c-o.data.softness)*a,n==tt.mixOut?(o.bendDirection=o.data.bendDirection,o.compress=o.data.compress,o.stretch=o.data.stretch):(o.bendDirection=l[d+3],o.compress=0!=l[d+4],o.stretch=0!=l[d+5])):(o.mix+=(h-o.mix)*a,o.softness+=(c-o.softness)*a,n==tt.mixIn&&(o.bendDirection=l[d+3],o.compress=0!=l[d+4],o.stretch=0!=l[d+5]))}}class Tt extends at{constructor(t,s,i){super(t,s,[st.transformConstraint+"|"+i]),e(this,"constraintIndex",0),this.constraintIndex=i}getFrameEntries(){return 7}setFrame(t,e,s,i,a,r,n,o){let l=this.frames;l[t*=7]=e,l[t+1]=s,l[t+2]=i,l[t+3]=a,l[t+4]=r,l[t+5]=n,l[t+6]=o}apply(t,e,s,i,a,r,n){let o=t.transformConstraints[this.constraintIndex];if(!o.active)return;let l,h,c,d,u,m,f=this.frames;if(s<f[0]){let t=o.data;switch(r){case J.setup:return o.mixRotate=t.mixRotate,o.mixX=t.mixX,o.mixY=t.mixY,o.mixScaleX=t.mixScaleX,o.mixScaleY=t.mixScaleY,void(o.mixShearY=t.mixShearY);case J.first:o.mixRotate+=(t.mixRotate-o.mixRotate)*a,o.mixX+=(t.mixX-o.mixX)*a,o.mixY+=(t.mixY-o.mixY)*a,o.mixScaleX+=(t.mixScaleX-o.mixScaleX)*a,o.mixScaleY+=(t.mixScaleY-o.mixScaleY)*a,o.mixShearY+=(t.mixShearY-o.mixShearY)*a}return}let g=it.search(f,s,7),p=this.curves[g/7];switch(p){case 0:let t=f[g];l=f[g+1],h=f[g+2],c=f[g+3],d=f[g+4],u=f[g+5],m=f[g+6];let e=(s-t)/(f[g+7]-t);l+=(f[g+7+1]-l)*e,h+=(f[g+7+2]-h)*e,c+=(f[g+7+3]-c)*e,d+=(f[g+7+4]-d)*e,u+=(f[g+7+5]-u)*e,m+=(f[g+7+6]-m)*e;break;case 1:l=f[g+1],h=f[g+2],c=f[g+3],d=f[g+4],u=f[g+5],m=f[g+6];break;default:l=this.getBezierValue(s,g,1,p-2),h=this.getBezierValue(s,g,2,p+18-2),c=this.getBezierValue(s,g,3,p+36-2),d=this.getBezierValue(s,g,4,p+54-2),u=this.getBezierValue(s,g,5,p+72-2),m=this.getBezierValue(s,g,6,p+90-2)}if(r==J.setup){let t=o.data;o.mixRotate=t.mixRotate+(l-t.mixRotate)*a,o.mixX=t.mixX+(h-t.mixX)*a,o.mixY=t.mixY+(c-t.mixY)*a,o.mixScaleX=t.mixScaleX+(d-t.mixScaleX)*a,o.mixScaleY=t.mixScaleY+(u-t.mixScaleY)*a,o.mixShearY=t.mixShearY+(m-t.mixShearY)*a}else o.mixRotate+=(l-o.mixRotate)*a,o.mixX+=(h-o.mixX)*a,o.mixY+=(c-o.mixY)*a,o.mixScaleX+=(d-o.mixScaleX)*a,o.mixScaleY+=(u-o.mixScaleY)*a,o.mixShearY+=(m-o.mixShearY)*a}}class Xt extends rt{constructor(t,s,i){super(t,s,st.pathConstraintPosition+"|"+i),e(this,"constraintIndex",0),this.constraintIndex=i}apply(t,e,s,i,a,r,n){let o=t.pathConstraints[this.constraintIndex];o.active&&(o.position=this.getAbsoluteValue(s,a,r,o.position,o.data.position))}}class Rt extends rt{constructor(t,s,i){super(t,s,st.pathConstraintSpacing+"|"+i),e(this,"constraintIndex",0),this.constraintIndex=i}apply(t,e,s,i,a,r,n){let o=t.pathConstraints[this.constraintIndex];o.active&&(o.spacing=this.getAbsoluteValue(s,a,r,o.spacing,o.data.spacing))}}class Pt extends at{constructor(t,s,i){super(t,s,[st.pathConstraintMix+"|"+i]),e(this,"constraintIndex",0),this.constraintIndex=i}getFrameEntries(){return 4}setFrame(t,e,s,i,a){let r=this.frames;r[t<<=2]=e,r[t+1]=s,r[t+2]=i,r[t+3]=a}apply(t,e,s,i,a,r,n){let o=t.pathConstraints[this.constraintIndex];if(!o.active)return;let l,h,c,d=this.frames;if(s<d[0]){switch(r){case J.setup:return o.mixRotate=o.data.mixRotate,o.mixX=o.data.mixX,void(o.mixY=o.data.mixY);case J.first:o.mixRotate+=(o.data.mixRotate-o.mixRotate)*a,o.mixX+=(o.data.mixX-o.mixX)*a,o.mixY+=(o.data.mixY-o.mixY)*a}return}let u=it.search(d,s,4),m=this.curves[u>>2];switch(m){case 0:let t=d[u];l=d[u+1],h=d[u+2],c=d[u+3];let e=(s-t)/(d[u+4]-t);l+=(d[u+4+1]-l)*e,h+=(d[u+4+2]-h)*e,c+=(d[u+4+3]-c)*e;break;case 1:l=d[u+1],h=d[u+2],c=d[u+3];break;default:l=this.getBezierValue(s,u,1,m-2),h=this.getBezierValue(s,u,2,m+18-2),c=this.getBezierValue(s,u,3,m+36-2)}if(r==J.setup){let t=o.data;o.mixRotate=t.mixRotate+(l-t.mixRotate)*a,o.mixX=t.mixX+(h-t.mixX)*a,o.mixY=t.mixY+(c-t.mixY)*a}else o.mixRotate+=(l-o.mixRotate)*a,o.mixX+=(h-o.mixX)*a,o.mixY+=(c-o.mixY)*a}}class Et extends rt{constructor(t,s,i,a){super(t,s,a+"|"+i),e(this,"constraintIndex",0),this.constraintIndex=i}apply(t,e,s,i,a,r,n){let o;if(-1==this.constraintIndex){const e=s>=this.frames[0]?this.getCurveValue(s):0;for(const i of t.physicsConstraints)i.active&&this.global(i.data)&&this.set(i,this.getAbsoluteValue2(s,a,r,this.get(i),this.setup(i),e))}else o=t.physicsConstraints[this.constraintIndex],o.active&&this.set(o,this.getAbsoluteValue(s,a,r,this.get(o),this.setup(o)))}}class Bt extends Et{constructor(t,e,s){super(t,e,s,st.physicsConstraintInertia)}setup(t){return t.data.inertia}get(t){return t.inertia}set(t,e){t.inertia=e}global(t){return t.inertiaGlobal}}class Vt extends Et{constructor(t,e,s){super(t,e,s,st.physicsConstraintStrength)}setup(t){return t.data.strength}get(t){return t.strength}set(t,e){t.strength=e}global(t){return t.strengthGlobal}}class Dt extends Et{constructor(t,e,s){super(t,e,s,st.physicsConstraintDamping)}setup(t){return t.data.damping}get(t){return t.damping}set(t,e){t.damping=e}global(t){return t.dampingGlobal}}class _t extends Et{constructor(t,e,s){super(t,e,s,st.physicsConstraintMass)}setup(t){return 1/t.data.massInverse}get(t){return 1/t.massInverse}set(t,e){t.massInverse=1/e}global(t){return t.massGlobal}}class Nt extends Et{constructor(t,e,s){super(t,e,s,st.physicsConstraintWind)}setup(t){return t.data.wind}get(t){return t.wind}set(t,e){t.wind=e}global(t){return t.windGlobal}}class Ot extends Et{constructor(t,e,s){super(t,e,s,st.physicsConstraintGravity)}setup(t){return t.data.gravity}get(t){return t.gravity}set(t,e){t.gravity=e}global(t){return t.gravityGlobal}}class Lt extends Et{constructor(t,e,s){super(t,e,s,st.physicsConstraintMix)}setup(t){return t.data.mix}get(t){return t.mix}set(t,e){t.mix=e}global(t){return t.mixGlobal}}const qt=class t extends it{constructor(s,i){super(s,t.propertyIds),e(this,"constraintIndex"),this.constraintIndex=i}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e}apply(t,e,s,i,a,r,n){let o;if(-1!=this.constraintIndex&&(o=t.physicsConstraints[this.constraintIndex],!o.active))return;const l=this.frames;if(e>s)this.apply(t,e,Number.MAX_VALUE,[],a,r,n),e=-1;else if(e>=l[l.length-1])return;if(!(s<l[0])&&(e<l[0]||s>=l[it.search1(l,e)+1]))if(null!=o)o.reset();else for(const h of t.physicsConstraints)h.active&&h.reset()}};e(qt,"propertyIds",[st.physicsConstraintReset.toString()]);let Wt=qt;const Ut=class t extends it{constructor(t,s,i){super(t,[st.sequence+"|"+s+"|"+i.sequence.id]),e(this,"slotIndex"),e(this,"attachment"),this.slotIndex=s,this.attachment=i}getFrameEntries(){return t.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(e,s,i,a,r){let n=this.frames;n[e*=t.ENTRIES]=s,n[e+t.MODE]=i|a<<4,n[e+t.DELAY]=r}apply(e,s,i,a,r,n,o){let l=e.slots[this.slotIndex];if(!l.bone.active)return;let h=l.attachment,c=this.attachment;if(!(h==c||h instanceof z&&h.timelineAttachment==c))return;if(o==tt.mixOut)return void(n==J.setup&&(l.sequenceIndex=-1));let d=this.frames;if(i<d[0])return void(n!=J.setup&&n!=J.first||(l.sequenceIndex=-1));let u=it.search(d,i,t.ENTRIES),m=d[u],f=d[u+t.MODE],g=d[u+t.DELAY];if(!this.attachment.sequence)return;let p=f>>4,b=this.attachment.sequence.regions.length,x=K[15&f];if(x!=$.hold)switch(p+=(i-m)/g+1e-5|0,x){case $.once:p=Math.min(b-1,p);break;case $.loop:p%=b;break;case $.pingpong:{let t=(b<<1)-2;p=0==t?0:p%t,p>=b&&(p=t-p);break}case $.onceReverse:p=Math.max(b-1-p,0);break;case $.loopReverse:p=b-1-p%b;break;case $.pingpongReverse:{let t=(b<<1)-2;p=0==t?0:(p+b-1)%t,p>=b&&(p=t-p)}}l.sequenceIndex=p}};e(Ut,"ENTRIES",3),e(Ut,"MODE",1),e(Ut,"DELAY",2);let zt=Ut;const jt=class t{constructor(t){e(this,"data"),e(this,"tracks",new Array),e(this,"timeScale",1),e(this,"unkeyedState",0),e(this,"events",new Array),e(this,"listeners",new Array),e(this,"queue",new Ht(this)),e(this,"propertyIDs",new E),e(this,"animationsChanged",!1),e(this,"trackEntryPool",new L(()=>new $t)),this.data=t}static emptyAnimation(){return t._emptyAnimation}update(t){t*=this.timeScale;let e=this.tracks;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(!i)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let a=t*i.timeScale;if(i.delay>0){if(i.delay-=a,i.delay>0)continue;a=-i.delay,i.delay=0}let r=i.next;if(r){let e=i.trackLast-r.delay;if(e>=0){for(r.delay=0,r.trackTime+=0==i.timeScale?0:(e/i.timeScale+t)*r.timeScale,i.trackTime+=a,this.setCurrent(s,r,!0);r.mixingFrom;)r.mixTime+=t,r=r.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&!i.mixingFrom){e[s]=null,this.queue.end(i),this.clearNext(i);continue}if(i.mixingFrom&&this.updateMixingFrom(i,t)){let t=i.mixingFrom;for(i.mixingFrom=null,t&&(t.mixingTo=null);t;)this.queue.end(t),t=t.mixingFrom}i.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){let s=t.mixingFrom;if(!s)return!0;let i=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,-1!=t.nextTrackLast&&t.mixTime>=t.mixDuration?(0!=s.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=s.mixingFrom,null!=s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),i):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();let e=this.events,s=this.tracks,i=!1;for(let d=0,u=s.length;d<u;d++){let r=s[d];if(!r||r.delay>0)continue;i=!0;let n=0==d?J.first:r.mixBlend,o=r.alpha;r.mixingFrom?o*=this.applyMixingFrom(r,t,n):r.trackTime>=r.trackEnd&&!r.next&&(o=0);let l=o>=r.alphaAttachmentThreshold,h=r.animationLast,c=r.getAnimationTime(),u=c,m=e;r.reverse&&(u=r.animation.duration-u,m=null);let f=r.animation.timelines,g=f.length;if(0==d&&1==o||n==J.add){0==d&&(l=!0);for(let e=0;e<g;e++){var a=f[e];a instanceof At?this.applyAttachmentTimeline(a,t,u,n,l):a.apply(t,h,u,m,o,n,tt.mixIn)}}else{let e=r.timelineMode,s=r.shortestRotation,i=!s&&r.timelinesRotation.length!=g<<1;i&&(r.timelinesRotation.length=g<<1);for(let a=0;a<g;a++){let c=f[a],d=e[a]==Jt?n:J.setup;!s&&c instanceof ot?this.applyRotateTimeline(c,t,u,o,d,r.timelinesRotation,a<<1,i):c instanceof At?this.applyAttachmentTimeline(c,t,u,n,l):c.apply(t,h,u,m,o,d,tt.mixIn)}}this.queueEvents(r,c),e.length=0,r.nextAnimationLast=c,r.nextTrackLast=r.trackTime}for(var r=this.unkeyedState+ie,n=t.slots,o=0,l=t.slots.length;o<l;o++){var h=n[o];if(h.attachmentState==r){var c=h.data.attachmentName;h.setAttachment(c?t.getAttachment(h.data.index,c):null)}}return this.unkeyedState+=2,this.queue.drain(),i}applyMixingFrom(t,e,s){let i=t.mixingFrom;i.mixingFrom&&this.applyMixingFrom(i,e,s);let a=0;0==t.mixDuration?(a=1,s==J.first&&(s=J.setup)):(a=t.mixTime/t.mixDuration,a>1&&(a=1),s!=J.first&&(s=i.mixBlend));let r=a<i.mixAttachmentThreshold,n=a<i.mixDrawOrderThreshold,o=i.animation.timelines,l=o.length,h=i.alpha*t.interruptAlpha,c=h*(1-a),d=i.animationLast,u=i.getAnimationTime(),m=u,f=null;if(i.reverse?m=i.animation.duration-m:a<i.eventThreshold&&(f=this.events),s==J.add)for(let g=0;g<l;g++)o[g].apply(e,d,m,f,c,s,tt.mixOut);else{let t=i.timelineMode,a=i.timelineHoldMix,u=i.shortestRotation,g=!u&&i.timelinesRotation.length!=l<<1;g&&(i.timelinesRotation.length=l<<1),i.totalAlpha=0;for(let p=0;p<l;p++){let l,b=o[p],x=tt.mixOut,w=0;switch(t[p]){case Jt:if(!n&&b instanceof Ft)continue;l=s,w=c;break;case Zt:l=J.setup,w=c;break;case te:l=s,w=h;break;case ee:l=J.setup,w=h;break;default:l=J.setup;let t=a[p];w=h*Math.max(0,1-t.mixTime/t.mixDuration)}i.totalAlpha+=w,!u&&b instanceof ot?this.applyRotateTimeline(b,e,m,w,l,i.timelinesRotation,p<<1,g):b instanceof At?this.applyAttachmentTimeline(b,e,m,l,r&&w>=i.alphaAttachmentThreshold):(n&&b instanceof Ft&&l==J.setup&&(x=tt.mixIn),b.apply(e,d,m,f,w,l,x))}}return t.mixDuration>0&&this.queueEvents(i,u),this.events.length=0,i.nextAnimationLast=u,i.nextTrackLast=i.trackTime,a}applyAttachmentTimeline(t,e,s,i,a){var r=e.slots[t.slotIndex];r.bone.active&&(s<t.frames[0]?i!=J.setup&&i!=J.first||this.setAttachment(e,r,r.data.attachmentName,a):this.setAttachment(e,r,t.attachmentNames[it.search1(t.frames,s)],a),r.attachmentState<=this.unkeyedState&&(r.attachmentState=this.unkeyedState+ie))}setAttachment(t,e,s,i){e.setAttachment(s?t.getAttachment(e.data.index,s):null),i&&(e.attachmentState=this.unkeyedState+ae)}applyRotateTimeline(t,e,s,i,a,r,n,o){if(o&&(r[n]=0),1==i)return void t.apply(e,0,s,null,1,a,tt.mixIn);let l=e.bones[t.boneIndex];if(!l.active)return;let h=0,c=0;if(s<t.frames[0])switch(a){case J.setup:l.rotation=l.data.rotation;default:return;case J.first:h=l.rotation,c=l.data.rotation}else h=a==J.setup?l.data.rotation:l.rotation,c=l.data.rotation+t.getCurveValue(s);let d=0,u=c-h;if(u-=360*Math.ceil(u/360-.5),0==u)d=r[n];else{let t=0,e=0;o?(t=0,e=u):(t=r[n],e=r[n+1]);let s=t-t%360;d=u+s;let i=u>=0,a=t>=0;Math.abs(e)<=90&&_.signum(e)!=_.signum(u)&&(Math.abs(t-s)>180?(d+=360*_.signum(t),a=i):0!=s?d-=360*_.signum(t):a=i),a!=i&&(d+=360*_.signum(t)),r[n]=d}r[n+1]=u,l.rotation=h+d*i}queueEvents(t,e){let s=t.animationStart,i=t.animationEnd,a=i-s,r=t.trackLast%a,n=this.events,o=0,l=n.length;for(;o<l;o++){let e=n[o];if(e.time<r)break;e.time>i||this.queue.event(t,e)}let h=!1;if(t.loop)if(0==a)h=!0;else{const e=Math.floor(t.trackTime/a);h=e>0&&e>Math.floor(t.trackLast/a)}else h=e>=i&&t.animationLast<i;for(h&&this.queue.complete(t);o<l;o++){let e=n[o];e.time<s||this.queue.event(t,e)}}clearTracks(){let t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;let e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){let t=s.mixingFrom;if(!t)break;this.queue.end(t),s.mixingFrom=null,s.mixingTo=null,s=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){let i=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,i&&(s&&this.queue.interrupt(i),e.mixingFrom=i,i.mixingTo=e,e.mixTime=0,i.mixingFrom&&i.mixDuration>0&&(e.interruptAlpha*=Math.min(1,i.mixTime/i.mixDuration)),i.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){let i=this.data.skeletonData.findAnimation(e);if(!i)throw new Error("Animation not found: "+e);return this.setAnimationWith(t,i,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let i=!0,a=this.expandToIndex(t);a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.clearNext(a),a=a.mixingFrom,i=!1):this.clearNext(a));let r=this.trackEntry(t,e,s,a);return this.setCurrent(t,r,i),this.queue.drain(),r}addAnimation(t,e,s=!1,i=0){let a=this.data.skeletonData.findAnimation(e);if(!a)throw new Error("Animation not found: "+e);return this.addAnimationWith(t,a,s,i)}addAnimationWith(t,e,s=!1,i=0){if(!e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(a)for(;a.next;)a=a.next;let r=this.trackEntry(t,e,s,a);return a?(a.next=r,r.previous=a,i<=0&&(i=Math.max(i+a.getTrackComplete()-r.mixDuration,0))):(this.setCurrent(t,r,!0),this.queue.drain(),i<0&&(i=0)),r.delay=i,r}setEmptyAnimation(e,s=0){let i=this.setAnimationWith(e,t.emptyAnimation(),!1);return i.mixDuration=s,i.trackEnd=s,i}addEmptyAnimation(e,s=0,i=0){let a=this.addAnimationWith(e,t.emptyAnimation(),!1,i);return i<=0&&(a.delay=Math.max(a.delay+a.mixDuration-s,0)),a.mixDuration=s,a.trackEnd=s,a}setEmptyAnimations(t=0){let e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,i=this.tracks.length;s<i;s++){let e=this.tracks[s];e&&this.setEmptyAnimation(e.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(O.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,i){let a=this.trackEntryPool.obtain();return a.reset(),a.trackIndex=t,a.animation=e,a.loop=s,a.holdPrevious=!1,a.reverse=!1,a.shortestRotation=!1,a.eventThreshold=0,a.alphaAttachmentThreshold=0,a.mixAttachmentThreshold=0,a.mixDrawOrderThreshold=0,a.animationStart=0,a.animationEnd=e.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.mixTime=0,a.mixDuration=i?this.data.getMix(i.animation,e):0,a.interruptAlpha=1,a.totalAlpha=0,a.mixBlend=J.replace,a}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();let t=this.tracks;for(let e=0,s=t.length;e<s;e++){let s=t[e];if(s){for(;s.mixingFrom;)s=s.mixingFrom;do{s.mixingTo&&s.mixBlend==J.add||this.computeHold(s),s=s.mixingTo}while(s)}}}computeHold(t){let e=t.mixingTo,s=t.animation.timelines,i=t.animation.timelines.length,a=t.timelineMode;a.length=i;let r=t.timelineHoldMix;r.length=0;let n=this.propertyIDs;if(e&&e.holdPrevious)for(let o=0;o<i;o++)a[o]=n.addAll(s[o].getPropertyIds())?ee:te;else t:for(let o=0;o<i;o++){let i=s[o],l=i.getPropertyIds();if(n.addAll(l))if(!e||i instanceof At||i instanceof Ft||i instanceof Ct||!e.animation.hasTimeline(l))a[o]=Zt;else{for(let s=e.mixingTo;s;s=s.mixingTo)if(!s.animation.hasTimeline(l)){if(t.mixDuration>0){a[o]=se,r[o]=s;continue t}break}a[o]=ee}else a[o]=Jt}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){let e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}};e(jt,"_emptyAnimation",new Q("<empty>",[],0));let Gt=jt;class $t{constructor(){e(this,"animation",null),e(this,"previous",null),e(this,"next",null),e(this,"mixingFrom",null),e(this,"mixingTo",null),e(this,"listener",null),e(this,"trackIndex",0),e(this,"loop",!1),e(this,"holdPrevious",!1),e(this,"reverse",!1),e(this,"shortestRotation",!1),e(this,"eventThreshold",0),e(this,"mixAttachmentThreshold",0),e(this,"alphaAttachmentThreshold",0),e(this,"mixDrawOrderThreshold",0),e(this,"animationStart",0),e(this,"animationEnd",0),e(this,"animationLast",0),e(this,"nextAnimationLast",0),e(this,"delay",0),e(this,"trackTime",0),e(this,"trackLast",0),e(this,"nextTrackLast",0),e(this,"trackEnd",0),e(this,"timeScale",0),e(this,"alpha",0),e(this,"mixTime",0),e(this,"_mixDuration",0),e(this,"interruptAlpha",0),e(this,"totalAlpha",0),e(this,"mixBlend",J.replace),e(this,"timelineMode",new Array),e(this,"timelineHoldMix",new Array),e(this,"timelinesRotation",new Array)}get mixDuration(){return this._mixDuration}set mixDuration(t){this._mixDuration=t}setMixDurationWithDelay(t,e){this._mixDuration=t,e<=0&&(e=null!=this.previous?Math.max(e+this.previous.getTrackComplete()-t,0):0),this.delay=e}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){let t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){let t=this.animationEnd-this.animationStart;if(0!=t){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}wasApplied(){return-1!=this.nextTrackLast}isNextReady(){return null!=this.next&&this.nextTrackLast-this.next.delay>=0}}class Ht{constructor(t){e(this,"objects",[]),e(this,"drainDisabled",!1),e(this,"animState"),this.animState=t}start(t){this.objects.push(Kt.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(Kt.interrupt),this.objects.push(t)}end(t){this.objects.push(Kt.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(Kt.dispose),this.objects.push(t)}complete(t){this.objects.push(Kt.complete),this.objects.push(t)}event(t,e){this.objects.push(Kt.event),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;let t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){let i=t[s],a=t[s+1];switch(i){case Kt.start:a.listener&&a.listener.start&&a.listener.start(a);for(let t=0;t<e.length;t++){let s=e[t];s.start&&s.start(a)}break;case Kt.interrupt:a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let t=0;t<e.length;t++){let s=e[t];s.interrupt&&s.interrupt(a)}break;case Kt.end:a.listener&&a.listener.end&&a.listener.end(a);for(let t=0;t<e.length;t++){let s=e[t];s.end&&s.end(a)}case Kt.dispose:a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let t=0;t<e.length;t++){let s=e[t];s.dispose&&s.dispose(a)}this.animState.trackEntryPool.free(a);break;case Kt.complete:a.listener&&a.listener.complete&&a.listener.complete(a);for(let t=0;t<e.length;t++){let s=e[t];s.complete&&s.complete(a)}break;case Kt.event:let i=t[2+s++];a.listener&&a.listener.event&&a.listener.event(a,i);for(let t=0;t<e.length;t++){let s=e[t];s.event&&s.event(a,i)}}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var Kt,Qt;(Qt=Kt||(Kt={}))[Qt.start=0]="start",Qt[Qt.interrupt=1]="interrupt",Qt[Qt.end=2]="end",Qt[Qt.dispose=3]="dispose",Qt[Qt.complete=4]="complete",Qt[Qt.event=5]="event";const Jt=0,Zt=1,te=2,ee=3,se=4,ie=1,ae=2;class re{constructor(t){if(e(this,"skeletonData"),e(this,"animationToMixTime",{}),e(this,"defaultMix",0),!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){let i=this.skeletonData.findAnimation(t);if(!i)throw new Error("Animation not found: "+t);let a=this.skeletonData.findAnimation(e);if(!a)throw new Error("Animation not found: "+e);this.setMixWith(i,a,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");let i=t.name+"."+e.name;this.animationToMixTime[i]=s}getMix(t,e){let s=t.name+"."+e.name,i=this.animationToMixTime[s];return void 0===i?this.defaultMix:i}}class ne extends z{constructor(t){super(t),e(this,"color",new V(1,1,1,1))}copy(){let t=new ne(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class oe extends z{constructor(t){super(t),e(this,"endSlot",null),e(this,"color",new V(.2275,.2275,.8078,1))}copy(){let t=new oe(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class le{constructor(t){e(this,"_image"),this._image=t}getImage(){return this._image}}var he,ce,de,ue;(ce=he||(he={}))[ce.Nearest=9728]="Nearest",ce[ce.Linear=9729]="Linear",ce[ce.MipMap=9987]="MipMap",ce[ce.MipMapNearestNearest=9984]="MipMapNearestNearest",ce[ce.MipMapLinearNearest=9985]="MipMapLinearNearest",ce[ce.MipMapNearestLinear=9986]="MipMapNearestLinear",ce[ce.MipMapLinearLinear=9987]="MipMapLinearLinear",(ue=de||(de={}))[ue.MirroredRepeat=33648]="MirroredRepeat",ue[ue.ClampToEdge=33071]="ClampToEdge",ue[ue.Repeat=10497]="Repeat";class me{constructor(){e(this,"texture"),e(this,"u",0),e(this,"v",0),e(this,"u2",0),e(this,"v2",0),e(this,"width",0),e(this,"height",0),e(this,"degrees",0),e(this,"offsetX",0),e(this,"offsetY",0),e(this,"originalWidth",0),e(this,"originalHeight",0)}}class fe{constructor(t){e(this,"pages",new Array),e(this,"regions",new Array);let s=new ge(t),i=new Array(4),a={size:t=>{t.width=parseInt(i[1]),t.height=parseInt(i[2])},format:()=>{},filter:t=>{t.minFilter=O.enumValue(he,i[1]),t.magFilter=O.enumValue(he,i[2])},repeat:t=>{-1!=i[1].indexOf("x")&&(t.uWrap=de.Repeat),-1!=i[1].indexOf("y")&&(t.vWrap=de.Repeat)},pma:t=>{t.pma="true"==i[1]}};var r={xy:t=>{t.x=parseInt(i[1]),t.y=parseInt(i[2])},size:t=>{t.width=parseInt(i[1]),t.height=parseInt(i[2])},bounds:t=>{t.x=parseInt(i[1]),t.y=parseInt(i[2]),t.width=parseInt(i[3]),t.height=parseInt(i[4])},offset:t=>{t.offsetX=parseInt(i[1]),t.offsetY=parseInt(i[2])},orig:t=>{t.originalWidth=parseInt(i[1]),t.originalHeight=parseInt(i[2])},offsets:t=>{t.offsetX=parseInt(i[1]),t.offsetY=parseInt(i[2]),t.originalWidth=parseInt(i[3]),t.originalHeight=parseInt(i[4])},rotate:t=>{let e=i[1];"true"==e?t.degrees=90:"false"!=e&&(t.degrees=parseInt(e))},index:t=>{t.index=parseInt(i[1])}};let n=s.readLine();for(;n&&0==n.trim().length;)n=s.readLine();for(;n&&0!=n.trim().length&&0!=s.readEntry(i,n);)n=s.readLine();let o=null,l=null,h=null;for(;null!==n;)if(0==n.trim().length)o=null,n=s.readLine();else if(o){let t=new be(o,n);for(;;){let e=s.readEntry(i,n=s.readLine());if(0==e)break;let a=r[i[0]];if(a)a(t);else{l||(l=[]),h||(h=[]),l.push(i[0]);let t=[];for(let s=0;s<e;s++)t.push(parseInt(i[s+1]));h.push(t)}}0==t.originalWidth&&0==t.originalHeight&&(t.originalWidth=t.width,t.originalHeight=t.height),l&&l.length>0&&h&&h.length>0&&(t.names=l,t.values=h,l=null,h=null),t.u=t.x/o.width,t.v=t.y/o.height,90==t.degrees?(t.u2=(t.x+t.height)/o.width,t.v2=(t.y+t.width)/o.height):(t.u2=(t.x+t.width)/o.width,t.v2=(t.y+t.height)/o.height),this.regions.push(t)}else{for(o=new pe(n.trim());0!=s.readEntry(i,n=s.readLine());){let t=a[i[0]];t&&t(o)}this.pages.push(o)}}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}setTextures(t,e=""){for(let s of this.pages)s.setTexture(t.get(e+s.name))}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].texture?.dispose()}}class ge{constructor(t){e(this,"lines"),e(this,"index",0),this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,e){if(!e)return 0;if(0==(e=e.trim()).length)return 0;let s=e.indexOf(":");if(-1==s)return 0;t[0]=e.substr(0,s).trim();for(let i=1,a=s+1;;i++){let s=e.indexOf(",",a);if(-1==s)return t[i]=e.substr(a).trim(),i;if(t[i]=e.substr(a,s-a).trim(),a=s+1,4==i)return 4}}}class pe{constructor(t){e(this,"name"),e(this,"minFilter",he.Nearest),e(this,"magFilter",he.Nearest),e(this,"uWrap",de.ClampToEdge),e(this,"vWrap",de.ClampToEdge),e(this,"texture",null),e(this,"width",0),e(this,"height",0),e(this,"pma",!1),e(this,"regions",new Array),this.name=t}setTexture(t){this.texture=t,t.setFilters(this.minFilter,this.magFilter),t.setWraps(this.uWrap,this.vWrap);for(let e of this.regions)e.texture=t}}class be extends me{constructor(t,s){super(),e(this,"page"),e(this,"name"),e(this,"x",0),e(this,"y",0),e(this,"offsetX",0),e(this,"offsetY",0),e(this,"originalWidth",0),e(this,"originalHeight",0),e(this,"index",0),e(this,"degrees",0),e(this,"names",null),e(this,"values",null),this.page=t,this.name=s,t.regions.push(this)}}class xe extends z{constructor(t,s){super(t),e(this,"region",null),e(this,"path"),e(this,"regionUVs",[]),e(this,"uvs",[]),e(this,"triangles",[]),e(this,"color",new V(1,1,1,1)),e(this,"width",0),e(this,"height",0),e(this,"hullLength",0),e(this,"edges",[]),e(this,"parentMesh",null),e(this,"sequence",null),e(this,"tempColor",new V(0,0,0,0)),this.path=s}updateRegion(){if(!this.region)throw new Error("Region not set.");let t=this.regionUVs;this.uvs&&this.uvs.length==t.length||(this.uvs=O.newFloatArray(t.length));let e=this.uvs,s=this.uvs.length,i=this.region.u,a=this.region.v,r=0,n=0;if(this.region instanceof be){let o=this.region,l=o.page,h=l.width,c=l.height;switch(o.degrees){case 90:i-=(o.originalHeight-o.offsetY-o.height)/h,a-=(o.originalWidth-o.offsetX-o.width)/c,r=o.originalHeight/h,n=o.originalWidth/c;for(let o=0;o<s;o+=2)e[o]=i+t[o+1]*r,e[o+1]=a+(1-t[o])*n;return;case 180:i-=(o.originalWidth-o.offsetX-o.width)/h,a-=o.offsetY/c,r=o.originalWidth/h,n=o.originalHeight/c;for(let o=0;o<s;o+=2)e[o]=i+(1-t[o])*r,e[o+1]=a+(1-t[o+1])*n;return;case 270:i-=o.offsetY/h,a-=o.offsetX/c,r=o.originalHeight/h,n=o.originalWidth/c;for(let o=0;o<s;o+=2)e[o]=i+(1-t[o+1])*r,e[o+1]=a+t[o]*n;return}i-=o.offsetX/h,a-=(o.originalHeight-o.offsetY-o.height)/c,r=o.originalWidth/h,n=o.originalHeight/c}else this.region?(r=this.region.u2-i,n=this.region.v2-a):(i=a=0,r=n=1);for(let o=0;o<s;o+=2)e[o]=i+t[o]*r,e[o+1]=a+t[o+1]*n}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();let t=new xe(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Array(this.regionUVs.length),O.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.uvs=this.uvs instanceof Float32Array?O.newFloatArray(this.uvs.length):new Array(this.uvs.length),O.arrayCopy(this.uvs,0,t.uvs,0,this.uvs.length),t.triangles=new Array(this.triangles.length),O.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=null!=this.sequence?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),O.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,s,i,a,r){null!=this.sequence&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,s,i,a,r)}newLinkedMesh(){let t=new xe(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),null!=t.region&&t.updateRegion(),t}}class we extends z{constructor(t){super(t),e(this,"lengths",[]),e(this,"closed",!1),e(this,"constantSpeed",!1),e(this,"color",new V(1,1,1,1))}copy(){let t=new we(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),O.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class ye extends z{constructor(t){super(t),e(this,"x",0),e(this,"y",0),e(this,"rotation",0),e(this,"color",new V(.38,.94,0,1))}computeWorldPosition(t,e){return e.x=this.x*t.a+this.y*t.b+t.worldX,e.y=this.x*t.c+this.y*t.d+t.worldY,e}computeWorldRotation(t){const e=this.rotation*_.degRad,s=Math.cos(e),i=Math.sin(e),a=s*t.a+i*t.b,r=s*t.c+i*t.d;return _.atan2Deg(r,a)}copy(){let t=new ye(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const ke=class t extends W{constructor(t,s){super(t),e(this,"x",0),e(this,"y",0),e(this,"scaleX",1),e(this,"scaleY",1),e(this,"rotation",0),e(this,"width",0),e(this,"height",0),e(this,"color",new V(1,1,1,1)),e(this,"path"),e(this,"region",null),e(this,"sequence",null),e(this,"offset",O.newFloatArray(8)),e(this,"uvs",O.newFloatArray(8)),e(this,"tempColor",new V(1,1,1,1)),this.path=s}updateRegion(){if(!this.region)throw new Error("Region not set.");let t=this.region,e=this.uvs;if(null==t)return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=1,e[5]=1,e[6]=1,void(e[7]=0);let s=this.width/this.region.originalWidth*this.scaleX,i=this.height/this.region.originalHeight*this.scaleY,a=-this.width/2*this.scaleX+this.region.offsetX*s,r=-this.height/2*this.scaleY+this.region.offsetY*i,n=a+this.region.width*s,o=r+this.region.height*i,l=this.rotation*_.degRad,h=Math.cos(l),c=Math.sin(l),d=this.x,u=this.y,m=a*h+d,f=a*c,g=r*h+u,p=r*c,b=n*h+d,x=n*c,w=o*h+u,y=o*c,k=this.offset;k[0]=m-p,k[1]=g+f,k[2]=m-y,k[3]=w+f,k[4]=b-y,k[5]=w+x,k[6]=b-p,k[7]=g+x,90==t.degrees?(e[0]=t.u2,e[1]=t.v2,e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,s,i){null!=this.sequence&&this.sequence.apply(t,this);let a=t.bone,r=this.offset,n=a.worldX,o=a.worldY,l=a.a,h=a.b,c=a.c,d=a.d,u=0,m=0;u=r[0],m=r[1],e[s]=u*l+m*h+n,e[s+1]=u*c+m*d+o,s+=i,u=r[2],m=r[3],e[s]=u*l+m*h+n,e[s+1]=u*c+m*d+o,s+=i,u=r[4],m=r[5],e[s]=u*l+m*h+n,e[s+1]=u*c+m*d+o,s+=i,u=r[6],m=r[7],e[s]=u*l+m*h+n,e[s+1]=u*c+m*d+o}copy(){let e=new t(this.name,this.path);return e.region=this.region,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,O.arrayCopy(this.uvs,0,e.uvs,0,8),O.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e.sequence=null!=this.sequence?this.sequence.copy():null,e}};e(ke,"X1",0),e(ke,"Y1",1),e(ke,"C1R",2),e(ke,"C1G",3),e(ke,"C1B",4),e(ke,"C1A",5),e(ke,"U1",6),e(ke,"V1",7),e(ke,"X2",8),e(ke,"Y2",9),e(ke,"C2R",10),e(ke,"C2G",11),e(ke,"C2B",12),e(ke,"C2A",13),e(ke,"U2",14),e(ke,"V2",15),e(ke,"X3",16),e(ke,"Y3",17),e(ke,"C3R",18),e(ke,"C3G",19),e(ke,"C3B",20),e(ke,"C3A",21),e(ke,"U3",22),e(ke,"V3",23),e(ke,"X4",24),e(ke,"Y4",25),e(ke,"C4R",26),e(ke,"C4G",27),e(ke,"C4B",28),e(ke,"C4A",29),e(ke,"U4",30),e(ke,"V4",31);let ve=ke;class Ae{constructor(t){e(this,"atlas"),this.atlas=t}loadSequence(t,e,s){let i=s.regions;for(let a=0,r=i.length;a<r;a++){let r=s.getPath(e,a),n=this.atlas.findRegion(r);if(null==n)throw new Error("Region not found in atlas: "+r+" (sequence: "+t+")");i[a]=n}}newRegionAttachment(t,e,s,i){let a=new ve(e,s);if(null!=i)this.loadSequence(e,s,i);else{let t=this.atlas.findRegion(s);if(!t)throw new Error("Region not found in atlas: "+s+" (region attachment: "+e+")");a.region=t}return a}newMeshAttachment(t,e,s,i){let a=new xe(e,s);if(null!=i)this.loadSequence(e,s,i);else{let t=this.atlas.findRegion(s);if(!t)throw new Error("Region not found in atlas: "+s+" (mesh attachment: "+e+")");a.region=t}return a}newBoundingBoxAttachment(t,e){return new ne(e)}newPathAttachment(t,e){return new we(e)}newPointAttachment(t,e){return new ye(e)}newClippingAttachment(t,e){return new oe(e)}}class Se{constructor(t,s,i){if(e(this,"index",0),e(this,"name"),e(this,"parent",null),e(this,"length",0),e(this,"x",0),e(this,"y",0),e(this,"rotation",0),e(this,"scaleX",1),e(this,"scaleY",1),e(this,"shearX",0),e(this,"shearY",0),e(this,"inherit",Ie.Normal),e(this,"skinRequired",!1),e(this,"color",new V),e(this,"icon"),e(this,"visible",!1),t<0)throw new Error("index must be >= 0.");if(!s)throw new Error("name cannot be null.");this.index=t,this.name=s,this.parent=i}}var Ie,Ce,Me,Fe,Ye,Te,Xe,Re;(Ce=Ie||(Ie={}))[Ce.Normal=0]="Normal",Ce[Ce.OnlyTranslation=1]="OnlyTranslation",Ce[Ce.NoRotationOrReflection=2]="NoRotationOrReflection",Ce[Ce.NoScale=3]="NoScale",Ce[Ce.NoScaleOrReflection=4]="NoScaleOrReflection";class Pe{constructor(t,s,i){if(e(this,"data"),e(this,"skeleton"),e(this,"parent",null),e(this,"children",new Array),e(this,"x",0),e(this,"y",0),e(this,"rotation",0),e(this,"scaleX",0),e(this,"scaleY",0),e(this,"shearX",0),e(this,"shearY",0),e(this,"ax",0),e(this,"ay",0),e(this,"arotation",0),e(this,"ascaleX",0),e(this,"ascaleY",0),e(this,"ashearX",0),e(this,"ashearY",0),e(this,"a",0),e(this,"b",0),e(this,"c",0),e(this,"d",0),e(this,"worldY",0),e(this,"worldX",0),e(this,"inherit",Ie.Normal),e(this,"sorted",!1),e(this,"active",!1),!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=s,this.parent=i,this.setToSetupPose()}isActive(){return this.active}update(t){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,i,a,r,n){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=i,this.ascaleY=a,this.ashearX=r,this.ashearY=n;let o=this.parent;if(!o){let o=this.skeleton;const l=o.scaleX,h=o.scaleY,c=(s+r)*_.degRad,d=(s+90+n)*_.degRad;return this.a=Math.cos(c)*i*l,this.b=Math.cos(d)*a*l,this.c=Math.sin(c)*i*h,this.d=Math.sin(d)*a*h,this.worldX=t*l+o.x,void(this.worldY=e*h+o.y)}let l=o.a,h=o.b,c=o.c,d=o.d;switch(this.worldX=l*t+h*e+o.worldX,this.worldY=c*t+d*e+o.worldY,this.inherit){case Ie.Normal:{const t=(s+r)*_.degRad,e=(s+90+n)*_.degRad,o=Math.cos(t)*i,u=Math.cos(e)*a,m=Math.sin(t)*i,f=Math.sin(e)*a;return this.a=l*o+h*m,this.b=l*u+h*f,this.c=c*o+d*m,void(this.d=c*u+d*f)}case Ie.OnlyTranslation:{const t=(s+r)*_.degRad,e=(s+90+n)*_.degRad;this.a=Math.cos(t)*i,this.b=Math.cos(e)*a,this.c=Math.sin(t)*i,this.d=Math.sin(e)*a;break}case Ie.NoRotationOrReflection:{let t=1/this.skeleton.scaleX,e=1/this.skeleton.scaleY;l*=t,c*=e;let o=l*l+c*c,u=0;o>1e-4?(o=Math.abs(l*d*e-h*t*c)/o,h=c*o,d=l*o,u=Math.atan2(c,l)*_.radDeg):(l=0,c=0,u=90-Math.atan2(d,h)*_.radDeg);const m=(s+r-u)*_.degRad,f=(s+n-u+90)*_.degRad,g=Math.cos(m)*i,p=Math.cos(f)*a,b=Math.sin(m)*i,x=Math.sin(f)*a;this.a=l*g-h*b,this.b=l*p-h*x,this.c=c*g+d*b,this.d=c*p+d*x;break}case Ie.NoScale:case Ie.NoScaleOrReflection:{s*=_.degRad;const t=Math.cos(s),e=Math.sin(s);let o=(l*t+h*e)/this.skeleton.scaleX,u=(c*t+d*e)/this.skeleton.scaleY,m=Math.sqrt(o*o+u*u);m>1e-5&&(m=1/m),o*=m,u*=m,m=Math.sqrt(o*o+u*u),this.inherit==Ie.NoScale&&l*d-h*c<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(m=-m),s=Math.PI/2+Math.atan2(u,o);const f=Math.cos(s)*m,g=Math.sin(s)*m;r*=_.degRad,n=(90+n)*_.degRad;const p=Math.cos(r)*i,b=Math.cos(n)*a,x=Math.sin(r)*i,w=Math.sin(n)*a;this.a=o*p+f*x,this.b=o*b+f*w,this.c=u*p+g*x,this.d=u*b+g*w;break}}this.a*=this.skeleton.scaleX,this.b*=this.skeleton.scaleX,this.c*=this.skeleton.scaleY,this.d*=this.skeleton.scaleY}setToSetupPose(){let t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY,this.inherit=t.inherit}updateAppliedTransform(){let t=this.parent;if(!t)return this.ax=this.worldX-this.skeleton.x,this.ay=this.worldY-this.skeleton.y,this.arotation=Math.atan2(this.c,this.a)*_.radDeg,this.ascaleX=Math.sqrt(this.a*this.a+this.c*this.c),this.ascaleY=Math.sqrt(this.b*this.b+this.d*this.d),this.ashearX=0,void(this.ashearY=Math.atan2(this.a*this.b+this.c*this.d,this.a*this.d-this.b*this.c)*_.radDeg);let e,s,i,a,r=t.a,n=t.b,o=t.c,l=t.d,h=1/(r*l-n*o),c=l*h,d=n*h,u=o*h,m=r*h,f=this.worldX-t.worldX,g=this.worldY-t.worldY;if(this.ax=f*c-g*d,this.ay=g*m-f*u,this.inherit==Ie.OnlyTranslation)e=this.a,s=this.b,i=this.c,a=this.d;else{switch(this.inherit){case Ie.NoRotationOrReflection:{let t=Math.abs(r*l-n*o)/(r*r+o*o);n=-o*this.skeleton.scaleX*t/this.skeleton.scaleY,l=r*this.skeleton.scaleY*t/this.skeleton.scaleX,h=1/(r*l-n*o),c=l*h,d=n*h;break}case Ie.NoScale:case Ie.NoScaleOrReflection:let t=_.cosDeg(this.rotation),e=_.sinDeg(this.rotation);r=(r*t+n*e)/this.skeleton.scaleX,o=(o*t+l*e)/this.skeleton.scaleY;let s=Math.sqrt(r*r+o*o);s>1e-5&&(s=1/s),r*=s,o*=s,s=Math.sqrt(r*r+o*o),this.inherit==Ie.NoScale&&h<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(s=-s);let i=_.PI/2+Math.atan2(o,r);n=Math.cos(i)*s,l=Math.sin(i)*s,h=1/(r*l-n*o),c=l*h,d=n*h,u=o*h,m=r*h}e=c*this.a-d*this.c,s=c*this.b-d*this.d,i=m*this.c-u*this.a,a=m*this.d-u*this.b}if(this.ashearX=0,this.ascaleX=Math.sqrt(e*e+i*i),this.ascaleX>1e-4){let t=e*a-s*i;this.ascaleY=t/this.ascaleX,this.ashearY=-Math.atan2(e*s+i*a,t)*_.radDeg,this.arotation=Math.atan2(i,e)*_.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(s*s+a*a),this.ashearY=0,this.arotation=90-Math.atan2(a,s)*_.radDeg}getWorldRotationX(){return Math.atan2(this.c,this.a)*_.radDeg}getWorldRotationY(){return Math.atan2(this.d,this.b)*_.radDeg}getWorldScaleX(){return Math.sqrt(this.a*this.a+this.c*this.c)}getWorldScaleY(){return Math.sqrt(this.b*this.b+this.d*this.d)}worldToLocal(t){let e=1/(this.a*this.d-this.b*this.c),s=t.x-this.worldX,i=t.y-this.worldY;return t.x=s*this.d*e-i*this.b*e,t.y=i*this.a*e-s*this.c*e,t}localToWorld(t){let e=t.x,s=t.y;return t.x=e*this.a+s*this.b+this.worldX,t.y=e*this.c+s*this.d+this.worldY,t}worldToParent(t){if(null==t)throw new Error("world cannot be null.");return null==this.parent?t:this.parent.worldToLocal(t)}parentToWorld(t){if(null==t)throw new Error("world cannot be null.");return null==this.parent?t:this.parent.localToWorld(t)}worldToLocalRotation(t){let e=_.sinDeg(t),s=_.cosDeg(t);return Math.atan2(this.a*e-this.c*s,this.d*s-this.b*e)*_.radDeg+this.rotation-this.shearX}localToWorldRotation(t){t-=this.rotation-this.shearX;let e=_.sinDeg(t),s=_.cosDeg(t);return Math.atan2(s*this.c+e*this.d,s*this.a+e*this.b)*_.radDeg}rotateWorld(t){t*=_.degRad;const e=Math.sin(t),s=Math.cos(t),i=this.a,a=this.b;this.a=s*i-e*this.c,this.b=s*a-e*this.d,this.c=e*i+s*this.c,this.d=e*a+s*this.d}}class Ee{constructor(t,s,i){e(this,"name"),e(this,"order"),e(this,"skinRequired"),this.name=t,this.order=s,this.skinRequired=i}}class Be{constructor(t,s){if(e(this,"data"),e(this,"intValue",0),e(this,"floatValue",0),e(this,"stringValue",null),e(this,"time",0),e(this,"volume",0),e(this,"balance",0),!s)throw new Error("data cannot be null.");this.time=t,this.data=s}}class Ve{constructor(t){e(this,"name"),e(this,"intValue",0),e(this,"floatValue",0),e(this,"stringValue",null),e(this,"audioPath",null),e(this,"volume",0),e(this,"balance",0),this.name=t}}class De{constructor(t,s){if(e(this,"data"),e(this,"bones"),e(this,"target"),e(this,"bendDirection",0),e(this,"compress",!1),e(this,"stretch",!1),e(this,"mix",1),e(this,"softness",0),e(this,"active",!1),!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){let i=s.findBone(t.bones[e].name);if(!i)throw new Error(`Couldn't find bone ${t.bones[e].name}`);this.bones.push(i)}let i=s.findBone(t.target.name);if(!i)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=i,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch}isActive(){return this.active}setToSetupPose(){const t=this.data;this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch}update(t){if(0==this.mix)return;let e=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],e.worldX,e.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],e.worldX,e.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix)}}apply1(t,e,s,i,a,r,n){let o=t.parent;if(!o)throw new Error("IK bone must have parent.");let l=o.a,h=o.b,c=o.c,d=o.d,u=-t.ashearX-t.arotation,m=0,f=0;switch(t.inherit){case Ie.OnlyTranslation:m=(e-t.worldX)*_.signum(t.skeleton.scaleX),f=(s-t.worldY)*_.signum(t.skeleton.scaleY);break;case Ie.NoRotationOrReflection:let i=Math.abs(l*d-h*c)/Math.max(1e-4,l*l+c*c),a=l/t.skeleton.scaleX,r=c/t.skeleton.scaleY;h=-r*i*t.skeleton.scaleX,d=a*i*t.skeleton.scaleY,u+=Math.atan2(r,a)*_.radDeg;default:let n=e-o.worldX,g=s-o.worldY,p=l*d-h*c;Math.abs(p)<=1e-4?(m=0,f=0):(m=(n*d-g*h)/p-t.ax,f=(g*l-n*c)/p-t.ay)}u+=Math.atan2(f,m)*_.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let g=t.ascaleX,p=t.ascaleY;if(i||a){switch(t.inherit){case Ie.NoScale:case Ie.NoScaleOrReflection:m=e-t.worldX,f=s-t.worldY}const o=t.data.length*g;if(o>1e-4){const t=m*m+f*f;if(i&&t<o*o||a&&t>o*o){const e=(Math.sqrt(t)/o-1)*n+1;g*=e,r&&(p*=e)}}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*n,g,p,t.ashearX,t.ashearY)}apply2(t,e,s,i,a,r,n,o,l){if(t.inherit!=Ie.Normal||e.inherit!=Ie.Normal)return;let h=t.ax,c=t.ay,d=t.ascaleX,u=t.ascaleY,m=d,f=u,g=e.ascaleX,p=0,b=0,x=0;d<0?(d=-d,p=180,x=-1):(p=0,x=1),u<0&&(u=-u,x=-x),g<0?(g=-g,b=180):b=0;let w=e.ax,y=0,k=0,v=0,A=t.a,S=t.b,I=t.c,C=t.d,M=Math.abs(d-u)<=1e-4;!M||r?(y=0,k=A*w+t.worldX,v=I*w+t.worldY):(y=e.ay,k=A*w+S*y+t.worldX,v=I*w+C*y+t.worldY);let F=t.parent;if(!F)throw new Error("IK parent must itself have a parent.");A=F.a,S=F.b,I=F.c,C=F.d;let Y=A*C-S*I,T=k-F.worldX,X=v-F.worldY;Y=Math.abs(Y)<=1e-4?0:1/Y;let R,P,E=(T*C-X*S)*Y-h,B=(X*A-T*I)*Y-c,V=Math.sqrt(E*E+B*B),D=e.data.length*g;if(V<1e-4)return this.apply1(t,s,i,!1,r,!1,l),void e.updateWorldTransformWith(w,y,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);T=s-F.worldX,X=i-F.worldY;let N=(T*C-X*S)*Y-h,O=(X*A-T*I)*Y-c,L=N*N+O*O;if(0!=o){o*=d*(g+1)*.5;let t=Math.sqrt(L),e=t-V-D*d+o;if(e>0){let s=Math.min(1,e/(2*o))-1;s=(e-o*(1-s*s))/t,N-=s*N,O-=s*O,L=N*N+O*O}}t:if(M){D*=d;let t=(L-V*V-D*D)/(2*V*D);t<-1?(t=-1,P=Math.PI*a):t>1?(t=1,P=0,r&&(A=(Math.sqrt(L)/(V+D)-1)*l+1,m*=A,n&&(f*=A))):P=Math.acos(t)*a,A=V+D*t,S=D*Math.sin(P),R=Math.atan2(O*A-N*S,N*A+O*S)}else{A=d*D,S=u*D;let t=A*A,e=S*S,s=Math.atan2(O,N);I=e*V*V+t*L-t*e;let i=-2*e*V,r=e-t;if(C=i*i-4*r*I,C>=0){let t=Math.sqrt(C);i<0&&(t=-t),t=.5*-(i+t);let e=t/r,n=I/t,o=Math.abs(e)<Math.abs(n)?e:n;if(e=L-o*o,e>=0){X=Math.sqrt(e)*a,R=s-Math.atan2(X,o),P=Math.atan2(X/u,(o-V)/d);break t}}let n=_.PI,o=V-A,l=o*o,h=0,c=0,m=V+A,f=m*m,g=0;I=-A*V/(t-e),I>=-1&&I<=1&&(I=Math.acos(I),T=A*Math.cos(I)+V,X=S*Math.sin(I),C=T*T+X*X,C<l&&(n=I,l=C,o=T,h=X),C>f&&(c=I,f=C,m=T,g=X)),L<=.5*(l+f)?(R=s-Math.atan2(h*a,o),P=n*a):(R=s-Math.atan2(g*a,m),P=c*a)}let q=Math.atan2(y,w)*x,W=t.arotation;R=(R-q)*_.radDeg+p-W,R>180?R-=360:R<-180&&(R+=360),t.updateWorldTransformWith(h,c,W+R*l,m,f,0,0),W=e.arotation,P=((P+q)*_.radDeg-e.ashearX)*x+b-W,P>180?P-=360:P<-180&&(P+=360),e.updateWorldTransformWith(w,y,W+P*l,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}class _e extends Ee{constructor(t){super(t,0,!1),e(this,"bones",new Array),e(this,"_target",null),e(this,"bendDirection",0),e(this,"compress",!1),e(this,"stretch",!1),e(this,"uniform",!1),e(this,"mix",0),e(this,"softness",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Ne extends Ee{constructor(t){super(t,0,!1),e(this,"bones",new Array),e(this,"_target",null),e(this,"positionMode",Me.Fixed),e(this,"spacingMode",Ye.Fixed),e(this,"rotateMode",Xe.Chain),e(this,"offsetRotation",0),e(this,"position",0),e(this,"spacing",0),e(this,"mixRotate",0),e(this,"mixX",0),e(this,"mixY",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}(Fe=Me||(Me={}))[Fe.Fixed=0]="Fixed",Fe[Fe.Percent=1]="Percent",(Te=Ye||(Ye={}))[Te.Length=0]="Length",Te[Te.Fixed=1]="Fixed",Te[Te.Percent=2]="Percent",Te[Te.Proportional=3]="Proportional",(Re=Xe||(Xe={}))[Re.Tangent=0]="Tangent",Re[Re.Chain=1]="Chain",Re[Re.ChainScale=2]="ChainScale";const Oe=class t{constructor(t,s){if(e(this,"data"),e(this,"bones"),e(this,"target"),e(this,"position",0),e(this,"spacing",0),e(this,"mixRotate",0),e(this,"mixX",0),e(this,"mixY",0),e(this,"spaces",new Array),e(this,"positions",new Array),e(this,"world",new Array),e(this,"curves",new Array),e(this,"lengths",new Array),e(this,"segments",new Array),e(this,"active",!1),!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let e=0,a=t.bones.length;e<a;e++){let i=s.findBone(t.bones[e].name);if(!i)throw new Error(`Couldn't find bone ${t.bones[e].name}.`);this.bones.push(i)}let i=s.findSlot(t.target.name);if(!i)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=i,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}setToSetupPose(){const t=this.data;this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}update(e){let s=this.target.getAttachment();if(!(s instanceof we))return;let i=this.mixRotate,a=this.mixX,r=this.mixY;if(0==i&&0==a&&0==r)return;let n=this.data,o=n.rotateMode==Xe.Tangent,l=n.rotateMode==Xe.ChainScale,h=this.bones,c=h.length,d=o?c:c+1,u=O.setArraySize(this.spaces,d),m=l?this.lengths=O.setArraySize(this.lengths,c):[],f=this.spacing;switch(n.spacingMode){case Ye.Percent:if(l)for(let t=0,i=d-1;t<i;t++){let e=h[t],s=e.data.length,i=s*e.a,a=s*e.c;m[t]=Math.sqrt(i*i+a*a)}O.arrayFill(u,1,d,f);break;case Ye.Proportional:let e=0;for(let i=0,a=d-1;i<a;){let s=h[i],a=s.data.length;if(a<t.epsilon)l&&(m[i]=0),u[++i]=f;else{let t=a*s.a,r=a*s.c,n=Math.sqrt(t*t+r*r);l&&(m[i]=n),u[++i]=n,e+=n}}if(e>0){e=d/e*f;for(let t=1;t<d;t++)u[t]*=e}break;default:let s=n.spacingMode==Ye.Length;for(let i=0,a=d-1;i<a;){let e=h[i],a=e.data.length;if(a<t.epsilon)l&&(m[i]=0),u[++i]=f;else{let t=a*e.a,r=a*e.c,n=Math.sqrt(t*t+r*r);l&&(m[i]=n),u[++i]=(s?a+f:f)*n/a}}}let g=this.computeWorldPositions(s,d,o),p=g[0],b=g[1],x=n.offsetRotation,w=!1;if(0==x)w=n.rotateMode==Xe.Chain;else{w=!1;let t=this.target.bone;x*=t.a*t.d-t.b*t.c>0?_.degRad:-.01745329277777778}for(let t=0,y=3;t<c;t++,y+=3){let e=h[t];e.worldX+=(p-e.worldX)*a,e.worldY+=(b-e.worldY)*r;let s=g[y],n=g[y+1],c=s-p,d=n-b;if(l){let s=m[t];if(0!=s){let t=(Math.sqrt(c*c+d*d)/s-1)*i+1;e.a*=t,e.c*=t}}if(p=s,b=n,i>0){let s=e.a,a=e.b,r=e.c,n=e.d,l=0,h=0,m=0;if(l=o?g[y-1]:0==u[t+1]?g[y+2]:Math.atan2(d,c),l-=Math.atan2(r,s),w){h=Math.cos(l),m=Math.sin(l);let t=e.data.length;p+=(t*(h*s-m*r)-c)*i,b+=(t*(m*s+h*r)-d)*i}else l+=x;l>_.PI?l-=_.PI2:l<-3.1415927&&(l+=_.PI2),l*=i,h=Math.cos(l),m=Math.sin(l),e.a=h*s-m*r,e.b=h*a-m*n,e.c=m*s+h*r,e.d=m*a+h*n}e.updateAppliedTransform()}}computeWorldPositions(e,s,i){let a=this.target,r=this.position,n=this.spaces,o=O.setArraySize(this.positions,3*s+2),l=this.world,h=e.closed,c=e.worldVerticesLength,d=c/6,u=t.NONE;if(!e.constantSpeed){let m=e.lengths;d-=h?1:2;let f,g=m[d];switch(this.data.positionMode==Me.Percent&&(r*=g),this.data.spacingMode){case Ye.Percent:f=g;break;case Ye.Proportional:f=g/s;break;default:f=1}l=O.setArraySize(this.world,8);for(let p=0,b=0,x=0;p<s;p++,b+=3){let s=n[p]*f;r+=s;let w=r;if(h)w%=g,w<0&&(w+=g),x=0;else{if(w<0){u!=t.BEFORE&&(u=t.BEFORE,e.computeWorldVertices(a,2,4,l,0,2)),this.addBeforePosition(w,l,0,o,b);continue}if(w>g){u!=t.AFTER&&(u=t.AFTER,e.computeWorldVertices(a,c-6,4,l,0,2)),this.addAfterPosition(w-g,l,0,o,b);continue}}for(;;x++){let t=m[x];if(!(w>t)){if(0==x)w/=t;else{let e=m[x-1];w=(w-e)/(t-e)}break}}x!=u&&(u=x,h&&x==d?(e.computeWorldVertices(a,c-4,4,l,0,2),e.computeWorldVertices(a,0,4,l,4,2)):e.computeWorldVertices(a,6*x+2,8,l,0,2)),this.addCurvePosition(w,l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],o,b,i||p>0&&0==s)}return o}h?(c+=2,l=O.setArraySize(this.world,c),e.computeWorldVertices(a,2,c-4,l,0,2),e.computeWorldVertices(a,0,2,l,c-4,2),l[c-2]=l[0],l[c-1]=l[1]):(d--,c-=4,l=O.setArraySize(this.world,c),e.computeWorldVertices(a,2,c,l,0,2));let m,f=O.setArraySize(this.curves,d),g=0,p=l[0],b=l[1],x=0,w=0,y=0,k=0,v=0,A=0,S=0,I=0,C=0,M=0,F=0,Y=0,T=0,X=0;for(let t=0,E=2;t<d;t++,E+=6)x=l[E],w=l[E+1],y=l[E+2],k=l[E+3],v=l[E+4],A=l[E+5],S=.1875*(p-2*x+y),I=.1875*(b-2*w+k),C=.09375*(3*(x-y)-p+v),M=.09375*(3*(w-k)-b+A),F=2*S+C,Y=2*I+M,T=.75*(x-p)+S+.16666667*C,X=.75*(w-b)+I+.16666667*M,g+=Math.sqrt(T*T+X*X),T+=F,X+=Y,F+=C,Y+=M,g+=Math.sqrt(T*T+X*X),T+=F,X+=Y,g+=Math.sqrt(T*T+X*X),T+=F+C,X+=Y+M,g+=Math.sqrt(T*T+X*X),f[t]=g,p=v,b=A;switch(this.data.positionMode==Me.Percent&&(r*=g),this.data.spacingMode){case Ye.Percent:m=g;break;case Ye.Proportional:m=g/s;break;default:m=1}let R=this.segments,P=0;for(let t=0,E=0,B=0,V=0;t<s;t++,E+=3){let e=n[t]*m;r+=e;let s=r;if(h)s%=g,s<0&&(s+=g),B=0;else{if(s<0){this.addBeforePosition(s,l,0,o,E);continue}if(s>g){this.addAfterPosition(s-g,l,c-4,o,E);continue}}for(;;B++){let t=f[B];if(!(s>t)){if(0==B)s/=t;else{let e=f[B-1];s=(s-e)/(t-e)}break}}if(B!=u){u=B;let t=6*B;for(p=l[t],b=l[t+1],x=l[t+2],w=l[t+3],y=l[t+4],k=l[t+5],v=l[t+6],A=l[t+7],S=.03*(p-2*x+y),I=.03*(b-2*w+k),C=.006*(3*(x-y)-p+v),M=.006*(3*(w-k)-b+A),F=2*S+C,Y=2*I+M,T=.3*(x-p)+S+.16666667*C,X=.3*(w-b)+I+.16666667*M,P=Math.sqrt(T*T+X*X),R[0]=P,t=1;t<8;t++)T+=F,X+=Y,F+=C,Y+=M,P+=Math.sqrt(T*T+X*X),R[t]=P;T+=F,X+=Y,P+=Math.sqrt(T*T+X*X),R[8]=P,T+=F+C,X+=Y+M,P+=Math.sqrt(T*T+X*X),R[9]=P,V=0}for(s*=P;;V++){let t=R[V];if(!(s>t)){if(0==V)s/=t;else{let e=R[V-1];s=V+(s-e)/(t-e)}break}}this.addCurvePosition(.1*s,p,b,x,w,y,k,v,A,o,E,i||t>0&&0==e)}return o}addBeforePosition(t,e,s,i,a){let r=e[s],n=e[s+1],o=e[s+2]-r,l=e[s+3]-n,h=Math.atan2(l,o);i[a]=r+t*Math.cos(h),i[a+1]=n+t*Math.sin(h),i[a+2]=h}addAfterPosition(t,e,s,i,a){let r=e[s+2],n=e[s+3],o=r-e[s],l=n-e[s+1],h=Math.atan2(l,o);i[a]=r+t*Math.cos(h),i[a+1]=n+t*Math.sin(h),i[a+2]=h}addCurvePosition(t,e,s,i,a,r,n,o,l,h,c,d){if(0==t||isNaN(t))return h[c]=e,h[c+1]=s,void(h[c+2]=Math.atan2(a-s,i-e));let u=t*t,m=u*t,f=1-t,g=f*f,p=g*f,b=f*t,x=3*b,w=f*x,y=x*t,k=e*p+i*w+r*y+o*m,v=s*p+a*w+n*y+l*m;h[c]=k,h[c+1]=v,d&&(h[c+2]=t<.001?Math.atan2(a-s,i-e):Math.atan2(v-(s*g+a*b*2+n*u),k-(e*g+i*b*2+r*u)))}};e(Oe,"NONE",-1),e(Oe,"BEFORE",-2),e(Oe,"AFTER",-3),e(Oe,"epsilon",1e-5);let Le=Oe;class qe{constructor(t,s){e(this,"data"),e(this,"_bone",null),e(this,"inertia",0),e(this,"strength",0),e(this,"damping",0),e(this,"massInverse",0),e(this,"wind",0),e(this,"gravity",0),e(this,"mix",0),e(this,"_reset",!0),e(this,"ux",0),e(this,"uy",0),e(this,"cx",0),e(this,"cy",0),e(this,"tx",0),e(this,"ty",0),e(this,"xOffset",0),e(this,"xVelocity",0),e(this,"yOffset",0),e(this,"yVelocity",0),e(this,"rotateOffset",0),e(this,"rotateVelocity",0),e(this,"scaleOffset",0),e(this,"scaleVelocity",0),e(this,"active",!1),e(this,"skeleton"),e(this,"remaining",0),e(this,"lastTime",0),this.data=t,this.skeleton=s,this.bone=s.bones[t.bone.index],this.inertia=t.inertia,this.strength=t.strength,this.damping=t.damping,this.massInverse=t.massInverse,this.wind=t.wind,this.gravity=t.gravity,this.mix=t.mix}set bone(t){this._bone=t}get bone(){if(this._bone)return this._bone;throw new Error("Bone not set.")}reset(){this.remaining=0,this.lastTime=this.skeleton.time,this._reset=!0,this.xOffset=0,this.xVelocity=0,this.yOffset=0,this.yVelocity=0,this.rotateOffset=0,this.rotateVelocity=0,this.scaleOffset=0,this.scaleVelocity=0}setToSetupPose(){const t=this.data;this.inertia=t.inertia,this.strength=t.strength,this.damping=t.damping,this.massInverse=t.massInverse,this.wind=t.wind,this.gravity=t.gravity,this.mix=t.mix}isActive(){return this.active}update(t){const e=this.mix;if(0==e)return;const s=this.data.x>0,i=this.data.y>0,a=this.data.rotate>0||this.data.shearX>0,r=this.data.scaleX>0,n=this.bone,o=n.data.length;switch(t){case Ge.none:return;case Ge.reset:this.reset();case Ge.update:const t=this.skeleton,l=Math.max(this.skeleton.time-this.lastTime,0);this.remaining+=l,this.lastTime=t.time;const h=n.worldX,c=n.worldY;if(this._reset)this._reset=!1,this.ux=h,this.uy=c;else{let d=this.remaining,u=this.inertia,m=this.data.step,f=this.skeleton.data.referenceScale,g=-1,p=this.data.limit*l,b=p*Math.abs(t.scaleY);if(p*=Math.abs(t.scaleX),s||i){if(s){const t=(this.ux-h)*u;this.xOffset+=t>p?p:t<-p?-p:t,this.ux=h}if(i){const t=(this.uy-c)*u;this.yOffset+=t>b?b:t<-b?-b:t,this.uy=c}if(d>=m){g=Math.pow(this.damping,60*m);const e=this.massInverse*m,a=this.strength,r=this.wind*f*t.scaleX,n=this.gravity*f*t.scaleY;do{s&&(this.xVelocity+=(r-this.xOffset*a)*e,this.xOffset+=this.xVelocity*m,this.xVelocity*=g),i&&(this.yVelocity-=(n+this.yOffset*a)*e,this.yOffset+=this.yVelocity*m,this.yVelocity*=g),d-=m}while(d>=m)}s&&(n.worldX+=this.xOffset*e*this.data.x),i&&(n.worldY+=this.yOffset*e*this.data.y)}if(a||r){let t=Math.atan2(n.c,n.a),s=0,i=0,l=0,h=this.cx-n.worldX,c=this.cy-n.worldY;if(h>p?h=p:h<-p&&(h=-p),c>b?c=b:c<-b&&(c=-b),a){l=(this.data.rotate+this.data.shearX)*e;let a=Math.atan2(c+this.ty,h+this.tx)-t-this.rotateOffset*l;this.rotateOffset+=(a-Math.ceil(a*_.invPI2-.5)*_.PI2)*u,a=this.rotateOffset*l+t,s=Math.cos(a),i=Math.sin(a),r&&(a=o*n.getWorldScaleX(),a>0&&(this.scaleOffset+=(h*s+c*i)*u/a))}else{s=Math.cos(t),i=Math.sin(t);const e=o*n.getWorldScaleX();e>0&&(this.scaleOffset+=(h*s+c*i)*u/e)}if(d=this.remaining,d>=m){-1==g&&(g=Math.pow(this.damping,60*m));const e=this.massInverse*m,n=this.strength,h=this.wind,c=je.yDown?-this.gravity:this.gravity,u=o/f;for(;;)if(d-=m,r&&(this.scaleVelocity+=(h*s-c*i-this.scaleOffset*n)*e,this.scaleOffset+=this.scaleVelocity*m,this.scaleVelocity*=g),a){if(this.rotateVelocity-=((h*i+c*s)*u+this.rotateOffset*n)*e,this.rotateOffset+=this.rotateVelocity*m,this.rotateVelocity*=g,d<m)break;const a=this.rotateOffset*l+t;s=Math.cos(a),i=Math.sin(a)}else if(d<m)break}}this.remaining=d}this.cx=n.worldX,this.cy=n.worldY;break;case Ge.pose:s&&(n.worldX+=this.xOffset*e*this.data.x),i&&(n.worldY+=this.yOffset*e*this.data.y)}if(a){let t=this.rotateOffset*e,s=0,i=0,a=0;if(this.data.shearX>0){let e=0;this.data.rotate>0&&(e=t*this.data.rotate,s=Math.sin(e),i=Math.cos(e),a=n.b,n.b=i*a-s*n.d,n.d=s*a+i*n.d),e+=t*this.data.shearX,s=Math.sin(e),i=Math.cos(e),a=n.a,n.a=i*a-s*n.c,n.c=s*a+i*n.c}else t*=this.data.rotate,s=Math.sin(t),i=Math.cos(t),a=n.a,n.a=i*a-s*n.c,n.c=s*a+i*n.c,a=n.b,n.b=i*a-s*n.d,n.d=s*a+i*n.d}if(r){const t=1+this.scaleOffset*e*this.data.scaleX;n.a*=t,n.c*=t}t!=Ge.pose&&(this.tx=o*n.a,this.ty=o*n.c),n.updateAppliedTransform()}translate(t,e){this.ux-=t,this.uy-=e,this.cx-=t,this.cy-=e}rotate(t,e,s){const i=s*_.degRad,a=Math.cos(i),r=Math.sin(i),n=this.cx-t,o=this.cy-e;this.translate(n*a-o*r-n,n*r+o*a-o)}}class We{constructor(t,s){if(e(this,"data"),e(this,"bone"),e(this,"color"),e(this,"darkColor",null),e(this,"attachment",null),e(this,"attachmentState",0),e(this,"sequenceIndex",-1),e(this,"deform",new Array),!t)throw new Error("data cannot be null.");if(!s)throw new Error("bone cannot be null.");this.data=t,this.bone=s,this.color=new V,this.darkColor=t.darkColor?new V:null,this.setToSetupPose()}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(t instanceof z&&this.attachment instanceof z&&t.timelineAttachment==this.attachment.timelineAttachment||(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class Ue{constructor(t,s){if(e(this,"data"),e(this,"bones"),e(this,"target"),e(this,"mixRotate",0),e(this,"mixX",0),e(this,"mixY",0),e(this,"mixScaleX",0),e(this,"mixScaleY",0),e(this,"mixShearY",0),e(this,"temp",new q),e(this,"active",!1),!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){let i=s.findBone(t.bones[e].name);if(!i)throw new Error(`Couldn't find bone ${t.bones[e].name}.`);this.bones.push(i)}let i=s.findBone(t.target.name);if(!i)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=i,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY}isActive(){return this.active}setToSetupPose(){const t=this.data;this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY}update(t){0==this.mixRotate&&0==this.mixX&&0==this.mixY&&0==this.mixScaleX&&0==this.mixScaleY&&0==this.mixShearY||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){let t=this.mixRotate,e=this.mixX,s=this.mixY,i=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,n=0!=e||0!=s,o=this.target,l=o.a,h=o.b,c=o.c,d=o.d,u=l*d-h*c>0?_.degRad:-.01745329277777778,m=this.data.offsetRotation*u,f=this.data.offsetShearY*u,g=this.bones;for(let p=0,b=g.length;p<b;p++){let u=g[p];if(0!=t){let e=u.a,s=u.b,i=u.c,a=u.d,r=Math.atan2(c,l)-Math.atan2(i,e)+m;r>_.PI?r-=_.PI2:r<-3.1415927&&(r+=_.PI2),r*=t;let n=Math.cos(r),o=Math.sin(r);u.a=n*e-o*i,u.b=n*s-o*a,u.c=o*e+n*i,u.d=o*s+n*a}if(n){let t=this.temp;o.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),u.worldX+=(t.x-u.worldX)*e,u.worldY+=(t.y-u.worldY)*s}if(0!=i){let t=Math.sqrt(u.a*u.a+u.c*u.c);0!=t&&(t=(t+(Math.sqrt(l*l+c*c)-t+this.data.offsetScaleX)*i)/t),u.a*=t,u.c*=t}if(0!=a){let t=Math.sqrt(u.b*u.b+u.d*u.d);0!=t&&(t=(t+(Math.sqrt(h*h+d*d)-t+this.data.offsetScaleY)*a)/t),u.b*=t,u.d*=t}if(r>0){let t=u.b,e=u.d,s=Math.atan2(e,t),i=Math.atan2(d,h)-Math.atan2(c,l)-(s-Math.atan2(u.c,u.a));i>_.PI?i-=_.PI2:i<-3.1415927&&(i+=_.PI2),i=s+(i+f)*r;let a=Math.sqrt(t*t+e*e);u.b=Math.cos(i)*a,u.d=Math.sin(i)*a}u.updateAppliedTransform()}}applyRelativeWorld(){let t=this.mixRotate,e=this.mixX,s=this.mixY,i=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,n=0!=e||0!=s,o=this.target,l=o.a,h=o.b,c=o.c,d=o.d,u=l*d-h*c>0?_.degRad:-.01745329277777778,m=this.data.offsetRotation*u,f=this.data.offsetShearY*u,g=this.bones;for(let p=0,b=g.length;p<b;p++){let u=g[p];if(0!=t){let e=u.a,s=u.b,i=u.c,a=u.d,r=Math.atan2(c,l)+m;r>_.PI?r-=_.PI2:r<-3.1415927&&(r+=_.PI2),r*=t;let n=Math.cos(r),o=Math.sin(r);u.a=n*e-o*i,u.b=n*s-o*a,u.c=o*e+n*i,u.d=o*s+n*a}if(n){let t=this.temp;o.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),u.worldX+=t.x*e,u.worldY+=t.y*s}if(0!=i){let t=(Math.sqrt(l*l+c*c)-1+this.data.offsetScaleX)*i+1;u.a*=t,u.c*=t}if(0!=a){let t=(Math.sqrt(h*h+d*d)-1+this.data.offsetScaleY)*a+1;u.b*=t,u.d*=t}if(r>0){let t=Math.atan2(d,h)-Math.atan2(c,l);t>_.PI?t-=_.PI2:t<-3.1415927&&(t+=_.PI2);let e=u.b,s=u.d;t=Math.atan2(s,e)+(t-_.PI/2+f)*r;let i=Math.sqrt(e*e+s*s);u.b=Math.cos(t)*i,u.d=Math.sin(t)*i}u.updateAppliedTransform()}}applyAbsoluteLocal(){let t=this.mixRotate,e=this.mixX,s=this.mixY,i=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,n=this.target,o=this.bones;for(let l=0,h=o.length;l<h;l++){let h=o[l],c=h.arotation;0!=t&&(c+=(n.arotation-c+this.data.offsetRotation)*t);let d=h.ax,u=h.ay;d+=(n.ax-d+this.data.offsetX)*e,u+=(n.ay-u+this.data.offsetY)*s;let m=h.ascaleX,f=h.ascaleY;0!=i&&0!=m&&(m=(m+(n.ascaleX-m+this.data.offsetScaleX)*i)/m),0!=a&&0!=f&&(f=(f+(n.ascaleY-f+this.data.offsetScaleY)*a)/f);let g=h.ashearY;0!=r&&(g+=(n.ashearY-g+this.data.offsetShearY)*r),h.updateWorldTransformWith(d,u,c,m,f,h.ashearX,g)}}applyRelativeLocal(){let t=this.mixRotate,e=this.mixX,s=this.mixY,i=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,n=this.target,o=this.bones;for(let l=0,h=o.length;l<h;l++){let h=o[l],c=h.arotation+(n.arotation+this.data.offsetRotation)*t,d=h.ax+(n.ax+this.data.offsetX)*e,u=h.ay+(n.ay+this.data.offsetY)*s,m=h.ascaleX*((n.ascaleX-1+this.data.offsetScaleX)*i+1),f=h.ascaleY*((n.ascaleY-1+this.data.offsetScaleY)*a+1),g=h.ashearY+(n.ashearY+this.data.offsetShearY)*r;h.updateWorldTransformWith(d,u,c,m,f,h.ashearX,g)}}}const ze=class t{constructor(t){if(e(this,"data"),e(this,"bones"),e(this,"slots"),e(this,"drawOrder"),e(this,"ikConstraints"),e(this,"transformConstraints"),e(this,"pathConstraints"),e(this,"physicsConstraints"),e(this,"_updateCache",new Array),e(this,"skin",null),e(this,"color"),e(this,"scaleX",1),e(this,"_scaleY",1),e(this,"x",0),e(this,"y",0),e(this,"time",0),!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){let s,i=t.bones[e];if(i.parent){let t=this.bones[i.parent.index];s=new Pe(i,this,t),t.children.push(s)}else s=new Pe(i,this,null);this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){let s=t.slots[e],i=this.bones[s.boneData.index],a=new We(s,i);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){let s=t.ikConstraints[e];this.ikConstraints.push(new De(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){let s=t.transformConstraints[e];this.transformConstraints.push(new Ue(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){let s=t.pathConstraints[e];this.pathConstraints.push(new Le(s,this))}this.physicsConstraints=new Array;for(let e=0;e<t.physicsConstraints.length;e++){let s=t.physicsConstraints[e];this.physicsConstraints.push(new qe(s,this))}this.color=new V(1,1,1,1),this.updateCache()}get scaleY(){return t.yDown?-this._scaleY:this._scaleY}set scaleY(t){this._scaleY=t}updateCache(){this._updateCache.length=0;let t=this.bones;for(let c=0,d=t.length;c<d;c++){let e=t[c];e.sorted=e.data.skinRequired,e.active=!e.sorted}if(this.skin){let t=this.skin.bones;for(let e=0,s=this.skin.bones.length;e<s;e++){let s=this.bones[t[e].index];do{s.sorted=!1,s.active=!0,s=s.parent}while(s)}}let e=this.ikConstraints,s=this.transformConstraints,i=this.pathConstraints,a=this.physicsConstraints,r=e.length,n=s.length,o=i.length,l=this.physicsConstraints.length,h=r+n+o+l;t:for(let c=0;c<h;c++){for(let t=0;t<r;t++){let s=e[t];if(s.data.order==c){this.sortIkConstraint(s);continue t}}for(let t=0;t<n;t++){let e=s[t];if(e.data.order==c){this.sortTransformConstraint(e);continue t}}for(let t=0;t<o;t++){let e=i[t];if(e.data.order==c){this.sortPathConstraint(e);continue t}}for(let t=0;t<l;t++){const e=a[t];if(e.data.order==c){this.sortPhysicsConstraint(e);continue t}}}for(let c=0,d=t.length;c<d;c++)this.sortBone(t[c])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&O.contains(this.skin.constraints,t.data,!0)),!t.active)return;let e=t.target;this.sortBone(e);let s=t.bones,i=s[0];if(this.sortBone(i),1==s.length)this._updateCache.push(t),this.sortReset(i.children);else{let e=s[s.length-1];this.sortBone(e),this._updateCache.push(t),this.sortReset(i.children),e.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&O.contains(this.skin.constraints,t.data,!0)),!t.active)return;let e=t.target,s=e.data.index,i=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,i),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,i);for(let o=0,l=this.data.skins.length;o<l;o++)this.sortPathConstraintAttachment(this.data.skins[o],s,i);let a=e.getAttachment();a instanceof we&&this.sortPathConstraintAttachmentWith(a,i);let r=t.bones,n=r.length;for(let o=0;o<n;o++)this.sortBone(r[o]);this._updateCache.push(t);for(let o=0;o<n;o++)this.sortReset(r[o].children);for(let o=0;o<n;o++)r[o].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&O.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);let e=t.bones,s=e.length;if(t.data.local)for(let i=0;i<s;i++){let t=e[i];this.sortBone(t.parent),this.sortBone(t)}else for(let i=0;i<s;i++)this.sortBone(e[i]);this._updateCache.push(t);for(let i=0;i<s;i++)this.sortReset(e[i].children);for(let i=0;i<s;i++)e[i].sorted=!0}sortPathConstraintAttachment(t,e,s){let i=t.attachments[e];if(i)for(let a in i)this.sortPathConstraintAttachmentWith(i[a],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof we))return;let s=t.bones;if(s){let t=this.bones;for(let e=0,i=s.length;e<i;){let i=s[e++];for(i+=e;e<i;)this.sortBone(t[s[e++]])}}else this.sortBone(e)}sortPhysicsConstraint(t){const e=t.bone;t.active=e.active&&(!t.data.skinRequired||null!=this.skin&&O.contains(this.skin.constraints,t.data,!0)),t.active&&(this.sortBone(e),this._updateCache.push(t),this.sortReset(e.children),e.sorted=!0)}sortBone(t){if(!t)return;if(t.sorted)return;let e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){let s=t[e];s.active&&(s.sorted&&this.sortReset(s.children),s.sorted=!1)}}updateWorldTransform(t){if(null==t)throw new Error("physics is undefined");let e=this.bones;for(let i=0,a=e.length;i<a;i++){let t=e[i];t.ax=t.x,t.ay=t.y,t.arotation=t.rotation,t.ascaleX=t.scaleX,t.ascaleY=t.scaleY,t.ashearX=t.shearX,t.ashearY=t.shearY}let s=this._updateCache;for(let i=0,a=s.length;i<a;i++)s[i].update(t)}updateWorldTransformWith(t,e){if(!e)throw new Error("parent cannot be null.");let s=this.bones;for(let g=1,p=s.length;g<p;g++){let t=s[g];t.ax=t.x,t.ay=t.y,t.arotation=t.rotation,t.ascaleX=t.scaleX,t.ascaleY=t.scaleY,t.ashearX=t.shearX,t.ashearY=t.shearY}let i=this.getRootBone();if(!i)throw new Error("Root bone must not be null.");let a=e.a,r=e.b,n=e.c,o=e.d;i.worldX=a*this.x+r*this.y+e.worldX,i.worldY=n*this.x+o*this.y+e.worldY;const l=(i.rotation+i.shearX)*_.degRad,h=(i.rotation+90+i.shearY)*_.degRad,c=Math.cos(l)*i.scaleX,d=Math.cos(h)*i.scaleY,u=Math.sin(l)*i.scaleX,m=Math.sin(h)*i.scaleY;i.a=(a*c+r*u)*this.scaleX,i.b=(a*d+r*m)*this.scaleX,i.c=(n*c+o*u)*this.scaleY,i.d=(n*d+o*m)*this.scaleY;let f=this._updateCache;for(let g=0,p=f.length;g<p;g++){let e=f[g];e!=i&&e.update(t)}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){for(const t of this.bones)t.setToSetupPose();for(const t of this.ikConstraints)t.setToSetupPose();for(const t of this.transformConstraints)t.setToSetupPose();for(const t of this.pathConstraints)t.setToSetupPose();for(const t of this.physicsConstraints)t.setToSetupPose()}setSlotsToSetupPose(){let t=this.slots;O.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");let e=this.bones;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(i.data.name==t)return i}return null}findSlot(t){if(!t)throw new Error("slotName cannot be null.");let e=this.slots;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(i.data.name==t)return i}return null}setSkinByName(t){let e=this.data.findSkin(t);if(!e)throw new Error("Skin not found: "+t);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{let e=this.slots;for(let s=0,i=e.length;s<i;s++){let i=e[s],a=i.data.attachmentName;if(a){let e=t.getAttachment(s,a);e&&i.setAttachment(e)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){let s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){let s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");let s=this.slots;for(let i=0,a=s.length;i<a;i++){let a=s[i];if(a.data.name==t){let s=null;if(e&&(s=this.getAttachment(i,e),!s))throw new Error("Attachment not found: "+e+", for slot: "+t);return void a.setAttachment(s)}}throw new Error("Slot not found: "+t)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");return this.ikConstraints.find(e=>e.data.name==t)??null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");return this.transformConstraints.find(e=>e.data.name==t)??null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");return this.pathConstraints.find(e=>e.data.name==t)??null}findPhysicsConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");return this.physicsConstraints.find(e=>e.data.name==t)??null}getBoundsRect(t){let e=new q,s=new q;return this.getBounds(e,s,void 0,t),{x:e.x,y:e.y,width:s.x,height:s.y}}getBounds(e,s,i=new Array(2),a=null){if(!e)throw new Error("offset cannot be null.");if(!s)throw new Error("size cannot be null.");let r=this.drawOrder,n=Number.POSITIVE_INFINITY,o=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let c=0,d=r.length;c<d;c++){let e=r[c];if(!e.bone.active)continue;let s=0,d=null,u=null,m=e.getAttachment();if(m instanceof ve)s=8,d=O.setArraySize(i,s,0),m.computeWorldVertices(e,d,0,2),u=t.quadTriangles;else if(m instanceof xe){let t=m;s=t.worldVerticesLength,d=O.setArraySize(i,s,0),t.computeWorldVertices(e,0,s,d,0,2),u=t.triangles}else if(m instanceof oe&&null!=a){a.clipStart(e,m);continue}if(d&&u){null!=a&&a.isClipping()&&(a.clipTriangles(d,u,u.length),d=a.clippedVertices,s=a.clippedVertices.length);for(let t=0,e=d.length;t<e;t+=2){let e=d[t],s=d[t+1];n=Math.min(n,e),o=Math.min(o,s),l=Math.max(l,e),h=Math.max(h,s)}}null!=a&&a.clipEndWithSlot(e)}null!=a&&a.clipEnd(),e.set(n,o),s.set(l-n,h-o)}update(t){this.time+=t}physicsTranslate(t,e){const s=this.physicsConstraints;for(let i=0,a=s.length;i<a;i++)s[i].translate(t,e)}physicsRotate(t,e,s){const i=this.physicsConstraints;for(let a=0,r=i.length;a<r;a++)i[a].rotate(t,e,s)}};e(ze,"quadTriangles",[0,1,2,2,3,0]),e(ze,"yDown",!1);let je=ze;var Ge,$e,He,Ke;($e=Ge||(Ge={}))[$e.none=0]="none",$e[$e.reset=1]="reset",$e[$e.update=2]="update",$e[$e.pose=3]="pose";class Qe extends Ee{constructor(t){super(t,0,!1),e(this,"_bone",null),e(this,"x",0),e(this,"y",0),e(this,"rotate",0),e(this,"scaleX",0),e(this,"shearX",0),e(this,"limit",0),e(this,"step",0),e(this,"inertia",0),e(this,"strength",0),e(this,"damping",0),e(this,"massInverse",0),e(this,"wind",0),e(this,"gravity",0),e(this,"mix",0),e(this,"inertiaGlobal",!1),e(this,"strengthGlobal",!1),e(this,"dampingGlobal",!1),e(this,"massGlobal",!1),e(this,"windGlobal",!1),e(this,"gravityGlobal",!1),e(this,"mixGlobal",!1)}set bone(t){this._bone=t}get bone(){if(this._bone)return this._bone;throw new Error("BoneData not set.")}}class Je{constructor(){e(this,"name",null),e(this,"bones",new Array),e(this,"slots",new Array),e(this,"skins",new Array),e(this,"defaultSkin",null),e(this,"events",new Array),e(this,"animations",new Array),e(this,"ikConstraints",new Array),e(this,"transformConstraints",new Array),e(this,"pathConstraints",new Array),e(this,"physicsConstraints",new Array),e(this,"x",0),e(this,"y",0),e(this,"width",0),e(this,"height",0),e(this,"referenceScale",100),e(this,"version",null),e(this,"hash",null),e(this,"fps",0),e(this,"imagesPath",null),e(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");let e=this.bones;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(i.name==t)return i}return null}findSlot(t){if(!t)throw new Error("slotName cannot be null.");let e=this.slots;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(i.name==t)return i}return null}findSkin(t){if(!t)throw new Error("skinName cannot be null.");let e=this.skins;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(i.name==t)return i}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");let e=this.events;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(i.name==t)return i}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");let e=this.animations;for(let s=0,i=e.length;s<i;s++){let i=e[s];if(i.name==t)return i}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,i=e.length;s<i;s++){const i=e[s];if(i.name==t)return i}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,i=e.length;s<i;s++){const i=e[s];if(i.name==t)return i}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,i=e.length;s<i;s++){const i=e[s];if(i.name==t)return i}return null}findPhysicsConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.physicsConstraints;for(let s=0,i=e.length;s<i;s++){const i=e[s];if(i.name==t)return i}return null}}class Ze{constructor(t=0,s,i){e(this,"slotIndex"),e(this,"name"),e(this,"attachment"),this.slotIndex=t,this.name=s,this.attachment=i}}class ts{constructor(t){if(e(this,"name"),e(this,"attachments",new Array),e(this,"bones",Array()),e(this,"constraints",new Array),e(this,"color",new V(.99607843,.61960787,.30980393,1)),!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");let i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][e]=s}addSkin(t){for(let i=0;i<t.bones.length;i++){let e=t.bones[i],s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==e){s=!0;break}s||this.bones.push(e)}for(let i=0;i<t.constraints.length;i++){let e=t.constraints[i],s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==e){s=!0;break}s||this.constraints.push(e)}let e=t.getAttachments();for(let i=0;i<e.length;i++){var s=e[i];this.setAttachment(s.slotIndex,s.name,s.attachment)}}copySkin(t){for(let i=0;i<t.bones.length;i++){let e=t.bones[i],s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==e){s=!0;break}s||this.bones.push(e)}for(let i=0;i<t.constraints.length;i++){let e=t.constraints[i],s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==e){s=!0;break}s||this.constraints.push(e)}let e=t.getAttachments();for(let i=0;i<e.length;i++){var s=e[i];s.attachment&&(s.attachment instanceof xe?(s.attachment=s.attachment.newLinkedMesh(),this.setAttachment(s.slotIndex,s.name,s.attachment)):(s.attachment=s.attachment.copy(),this.setAttachment(s.slotIndex,s.name,s.attachment)))}}getAttachment(t,e){let s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){let s=this.attachments[t];s&&delete s[e]}getAttachments(){let t=new Array;for(var e=0;e<this.attachments.length;e++){let s=this.attachments[e];if(s)for(let i in s){let a=s[i];a&&t.push(new Ze(e,i,a))}}return t}getAttachmentsForSlot(t,e){let s=this.attachments[t];if(s)for(let i in s){let a=s[i];a&&e.push(new Ze(t,i,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let i=0;i<t.slots.length;i++){let a=t.slots[i],r=a.getAttachment();if(r&&s<e.attachments.length){let t=e.attachments[s];for(let e in t){if(r==t[e]){let t=this.getAttachment(s,e);t&&a.setAttachment(t);break}}}s++}}}class es{constructor(t,s,i){if(e(this,"index",0),e(this,"name"),e(this,"boneData"),e(this,"color",new V(1,1,1,1)),e(this,"darkColor",null),e(this,"attachmentName",null),e(this,"blendMode",He.Normal),e(this,"visible",!0),t<0)throw new Error("index must be >= 0.");if(!s)throw new Error("name cannot be null.");if(!i)throw new Error("boneData cannot be null.");this.index=t,this.name=s,this.boneData=i}}(Ke=He||(He={}))[Ke.Normal=0]="Normal",Ke[Ke.Additive=1]="Additive",Ke[Ke.Multiply=2]="Multiply",Ke[Ke.Screen=3]="Screen";class ss extends Ee{constructor(t){super(t,0,!1),e(this,"bones",new Array),e(this,"_target",null),e(this,"mixRotate",0),e(this,"mixX",0),e(this,"mixY",0),e(this,"mixScaleX",0),e(this,"mixScaleY",0),e(this,"mixShearY",0),e(this,"offsetRotation",0),e(this,"offsetX",0),e(this,"offsetY",0),e(this,"offsetScaleX",0),e(this,"offsetScaleY",0),e(this,"offsetShearY",0),e(this,"relative",!1),e(this,"local",!1)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class is{constructor(t){e(this,"scale",1),e(this,"attachmentLoader"),e(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){let e=this.scale,s=new Je;s.name="";let i=new as(t),a=i.readInt32(),r=i.readInt32();s.hash=0==r&&0==a?null:r.toString(16)+a.toString(16),s.version=i.readString(),s.x=i.readFloat(),s.y=i.readFloat(),s.width=i.readFloat(),s.height=i.readFloat(),s.referenceScale=i.readFloat()*e;let n=i.readBoolean();n&&(s.fps=i.readFloat(),s.imagesPath=i.readString(),s.audioPath=i.readString());let o=0;o=i.readInt(!0);for(let h=0;h<o;h++){let t=i.readString();if(!t)throw new Error("String in string table must not be null.");i.strings.push(t)}o=i.readInt(!0);for(let h=0;h<o;h++){let t=i.readString();if(!t)throw new Error("Bone name must not be null.");let a=0==h?null:s.bones[i.readInt(!0)],r=new Se(h,t,a);r.rotation=i.readFloat(),r.x=i.readFloat()*e,r.y=i.readFloat()*e,r.scaleX=i.readFloat(),r.scaleY=i.readFloat(),r.shearX=i.readFloat(),r.shearY=i.readFloat(),r.length=i.readFloat()*e,r.inherit=i.readByte(),r.skinRequired=i.readBoolean(),n&&(V.rgba8888ToColor(r.color,i.readInt32()),r.icon=i.readString()??void 0,r.visible=i.readBoolean()),s.bones.push(r)}o=i.readInt(!0);for(let h=0;h<o;h++){let t=i.readString();if(!t)throw new Error("Slot name must not be null.");let e=s.bones[i.readInt(!0)],a=new es(h,t,e);V.rgba8888ToColor(a.color,i.readInt32());let r=i.readInt32();-1!=r&&V.rgb888ToColor(a.darkColor=new V,r),a.attachmentName=i.readStringRef(),a.blendMode=i.readInt(!0),n&&(a.visible=i.readBoolean()),s.slots.push(a)}o=i.readInt(!0);for(let h,c=0;c<o;c++){let t=i.readString();if(!t)throw new Error("IK constraint data name must not be null.");let a=new _e(t);a.order=i.readInt(!0),h=i.readInt(!0);for(let e=0;e<h;e++)a.bones.push(s.bones[i.readInt(!0)]);a.target=s.bones[i.readInt(!0)];let r=i.readByte();a.skinRequired=!!(1&r),a.bendDirection=2&r?1:-1,a.compress=!!(4&r),a.stretch=!!(8&r),a.uniform=!!(16&r),32&r&&(a.mix=64&r?i.readFloat():1),128&r&&(a.softness=i.readFloat()*e),s.ikConstraints.push(a)}o=i.readInt(!0);for(let h,c=0;c<o;c++){let t=i.readString();if(!t)throw new Error("Transform constraint data name must not be null.");let a=new ss(t);a.order=i.readInt(!0),h=i.readInt(!0);for(let e=0;e<h;e++)a.bones.push(s.bones[i.readInt(!0)]);a.target=s.bones[i.readInt(!0)];let r=i.readByte();a.skinRequired=!!(1&r),a.local=!!(2&r),a.relative=!!(4&r),8&r&&(a.offsetRotation=i.readFloat()),16&r&&(a.offsetX=i.readFloat()*e),32&r&&(a.offsetY=i.readFloat()*e),64&r&&(a.offsetScaleX=i.readFloat()),128&r&&(a.offsetScaleY=i.readFloat()),r=i.readByte(),1&r&&(a.offsetShearY=i.readFloat()),2&r&&(a.mixRotate=i.readFloat()),4&r&&(a.mixX=i.readFloat()),8&r&&(a.mixY=i.readFloat()),16&r&&(a.mixScaleX=i.readFloat()),32&r&&(a.mixScaleY=i.readFloat()),64&r&&(a.mixShearY=i.readFloat()),s.transformConstraints.push(a)}o=i.readInt(!0);for(let h,c=0;c<o;c++){let t=i.readString();if(!t)throw new Error("Path constraint data name must not be null.");let a=new Ne(t);a.order=i.readInt(!0),a.skinRequired=i.readBoolean(),h=i.readInt(!0);for(let e=0;e<h;e++)a.bones.push(s.bones[i.readInt(!0)]);a.target=s.slots[i.readInt(!0)];const r=i.readByte();a.positionMode=1&r,a.spacingMode=r>>1&3,a.rotateMode=r>>3&3,128&r&&(a.offsetRotation=i.readFloat()),a.position=i.readFloat(),a.positionMode==Me.Fixed&&(a.position*=e),a.spacing=i.readFloat(),a.spacingMode!=Ye.Length&&a.spacingMode!=Ye.Fixed||(a.spacing*=e),a.mixRotate=i.readFloat(),a.mixX=i.readFloat(),a.mixY=i.readFloat(),s.pathConstraints.push(a)}o=i.readInt(!0);for(let h=0;h<o;h++){const t=i.readString();if(!t)throw new Error("Physics constraint data name must not be null.");const a=new Qe(t);a.order=i.readInt(!0),a.bone=s.bones[i.readInt(!0)];let r=i.readByte();a.skinRequired=!!(1&r),2&r&&(a.x=i.readFloat()),4&r&&(a.y=i.readFloat()),8&r&&(a.rotate=i.readFloat()),16&r&&(a.scaleX=i.readFloat()),32&r&&(a.shearX=i.readFloat()),a.limit=(64&r?i.readFloat():5e3)*e,a.step=1/i.readUnsignedByte(),a.inertia=i.readFloat(),a.strength=i.readFloat(),a.damping=i.readFloat(),a.massInverse=128&r?i.readFloat():1,a.wind=i.readFloat(),a.gravity=i.readFloat(),r=i.readByte(),1&r&&(a.inertiaGlobal=!0),2&r&&(a.strengthGlobal=!0),4&r&&(a.dampingGlobal=!0),8&r&&(a.massGlobal=!0),16&r&&(a.windGlobal=!0),32&r&&(a.gravityGlobal=!0),64&r&&(a.mixGlobal=!0),a.mix=128&r?i.readFloat():1,s.physicsConstraints.push(a)}let l=this.readSkin(i,s,!0,n);l&&(s.defaultSkin=l,s.skins.push(l));{let t=s.skins.length;for(O.setArraySize(s.skins,o=t+i.readInt(!0));t<o;t++){let e=this.readSkin(i,s,!1,n);if(!e)throw new Error("readSkin() should not have returned null.");s.skins[t]=e}}o=this.linkedMeshes.length;for(let h=0;h<o;h++){let t=this.linkedMeshes[h];const e=s.skins[t.skinIndex];if(!t.parent)throw new Error("Linked mesh parent must not be null");let i=e.getAttachment(t.slotIndex,t.parent);if(!i)throw new Error(`Parent mesh not found: ${t.parent}`);t.mesh.timelineAttachment=t.inheritTimeline?i:t.mesh,t.mesh.setParentMesh(i),null!=t.mesh.region&&t.mesh.updateRegion()}this.linkedMeshes.length=0,o=i.readInt(!0);for(let h=0;h<o;h++){let t=i.readString();if(!t)throw new Error("Event data name must not be null");let e=new Ve(t);e.intValue=i.readInt(!1),e.floatValue=i.readFloat(),e.stringValue=i.readString(),e.audioPath=i.readString(),e.audioPath&&(e.volume=i.readFloat(),e.balance=i.readFloat()),s.events.push(e)}o=i.readInt(!0);for(let h=0;h<o;h++){let t=i.readString();if(!t)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(i,t,s))}return s}readSkin(t,e,s,i){let a=null,r=0;if(s){if(r=t.readInt(!0),0==r)return null;a=new ts("default")}else{let s=t.readString();if(!s)throw new Error("Skin name must not be null.");a=new ts(s),i&&V.rgba8888ToColor(a.color,t.readInt32()),a.bones.length=t.readInt(!0);for(let i=0,r=a.bones.length;i<r;i++)a.bones[i]=e.bones[t.readInt(!0)];for(let i=0,r=t.readInt(!0);i<r;i++)a.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let i=0,r=t.readInt(!0);i<r;i++)a.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let i=0,r=t.readInt(!0);i<r;i++)a.constraints.push(e.pathConstraints[t.readInt(!0)]);for(let i=0,r=t.readInt(!0);i<r;i++)a.constraints.push(e.physicsConstraints[t.readInt(!0)]);r=t.readInt(!0)}for(let n=0;n<r;n++){let s=t.readInt(!0);for(let r=0,n=t.readInt(!0);r<n;r++){let r=t.readStringRef();if(!r)throw new Error("Attachment name must not be null");let n=this.readAttachment(t,e,a,s,r,i);n&&a.setAttachment(s,r,n)}}return a}readAttachment(t,e,s,i,a,r){let n=this.scale,o=t.readByte();const l=8&o?t.readStringRef():a;if(!l)throw new Error("Attachment name must not be null");switch(7&o){case os.Region:{let e=16&o?t.readStringRef():null;const i=32&o?t.readInt32():4294967295,a=64&o?this.readSequence(t):null;let r=128&o?t.readFloat():0,h=t.readFloat(),c=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=t.readFloat(),f=t.readFloat();e||(e=l);let g=this.attachmentLoader.newRegionAttachment(s,l,e,a);return g?(g.path=e,g.x=h*n,g.y=c*n,g.scaleX=d,g.scaleY=u,g.rotation=r,g.width=m*n,g.height=f*n,V.rgba8888ToColor(g.color,i),g.sequence=a,null==a&&g.updateRegion(),g):null}case os.BoundingBox:{let e=this.readVertices(t,!!(16&o)),i=r?t.readInt32():0,a=this.attachmentLoader.newBoundingBoxAttachment(s,l);return a?(a.worldVerticesLength=e.length,a.vertices=e.vertices,a.bones=e.bones,r&&V.rgba8888ToColor(a.color,i),a):null}case os.Mesh:{let e=16&o?t.readStringRef():l;const i=32&o?t.readInt32():4294967295,a=64&o?this.readSequence(t):null,h=t.readInt(!0),c=this.readVertices(t,!!(128&o)),d=this.readFloatArray(t,c.length,1),u=this.readShortArray(t,3*(c.length-h-2));let m=[],f=0,g=0;r&&(m=this.readShortArray(t,t.readInt(!0)),f=t.readFloat(),g=t.readFloat()),e||(e=l);let p=this.attachmentLoader.newMeshAttachment(s,l,e,a);return p?(p.path=e,V.rgba8888ToColor(p.color,i),p.bones=c.bones,p.vertices=c.vertices,p.worldVerticesLength=c.length,p.triangles=u,p.regionUVs=d,null==a&&p.updateRegion(),p.hullLength=h<<1,p.sequence=a,r&&(p.edges=m,p.width=f*n,p.height=g*n),p):null}case os.LinkedMesh:{const e=16&o?t.readStringRef():l;if(null==e)throw new Error("Path of linked mesh must not be null");const a=32&o?t.readInt32():4294967295,h=64&o?this.readSequence(t):null,c=!!(128&o),d=t.readInt(!0),u=t.readStringRef();let m=0,f=0;r&&(m=t.readFloat(),f=t.readFloat());let g=this.attachmentLoader.newMeshAttachment(s,l,e,h);return g?(g.path=e,V.rgba8888ToColor(g.color,a),g.sequence=h,r&&(g.width=m*n,g.height=f*n),this.linkedMeshes.push(new rs(g,d,i,u,c)),g):null}case os.Path:{const e=!!(16&o),i=!!(32&o),a=this.readVertices(t,!!(64&o)),h=O.newArray(a.length/6,0);for(let s=0,r=h.length;s<r;s++)h[s]=t.readFloat()*n;const c=r?t.readInt32():0,d=this.attachmentLoader.newPathAttachment(s,l);return d?(d.closed=e,d.constantSpeed=i,d.worldVerticesLength=a.length,d.vertices=a.vertices,d.bones=a.bones,d.lengths=h,r&&V.rgba8888ToColor(d.color,c),d):null}case os.Point:{const e=t.readFloat(),i=t.readFloat(),a=t.readFloat(),o=r?t.readInt32():0,h=this.attachmentLoader.newPointAttachment(s,l);return h?(h.x=i*n,h.y=a*n,h.rotation=e,r&&V.rgba8888ToColor(h.color,o),h):null}case os.Clipping:{const i=t.readInt(!0),a=this.readVertices(t,!!(16&o));let n=r?t.readInt32():0,h=this.attachmentLoader.newClippingAttachment(s,l);return h?(h.endSlot=e.slots[i],h.worldVerticesLength=a.length,h.vertices=a.vertices,h.bones=a.bones,r&&V.rgba8888ToColor(h.color,n),h):null}}return null}readSequence(t){let e=new G(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readVertices(t,e){const s=this.scale,i=t.readInt(!0),a=new ns;if(a.length=i<<1,!e)return a.vertices=this.readFloatArray(t,a.length,s),a;let r=new Array,n=new Array;for(let o=0;o<i;o++){let e=t.readInt(!0);n.push(e);for(let i=0;i<e;i++)n.push(t.readInt(!0)),r.push(t.readFloat()*s),r.push(t.readFloat()*s),r.push(t.readFloat())}return a.vertices=O.toFloatArray(r),a.bones=n,a}readFloatArray(t,e,s){let i=new Array(e);if(1==s)for(let a=0;a<e;a++)i[a]=t.readFloat();else for(let a=0;a<e;a++)i[a]=t.readFloat()*s;return i}readShortArray(t,e){let s=new Array(e);for(let i=0;i<e;i++)s[i]=t.readInt(!0);return s}readAnimation(t,e,s){t.readInt(!0);let i=new Array,a=this.scale;for(let l=0,h=t.readInt(!0);l<h;l++){let e=t.readInt(!0);for(let s=0,a=t.readInt(!0);s<a;s++){let s=t.readByte(),a=t.readInt(!0),r=a-1;switch(s){case As:{let s=new At(a,e);for(let e=0;e<a;e++)s.setFrame(e,t.readFloat(),t.readStringRef());i.push(s);break}case Ss:{let s=t.readInt(!0),n=new xt(a,s,e),o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255;for(let e=0,i=0;n.setFrame(e,o,l,h,c,d),e!=r;e++){let s=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255;switch(t.readByte()){case qs:n.setStepped(e);break;case Ws:ds(t,n,i++,e,0,o,s,l,a,1),ds(t,n,i++,e,1,o,s,h,r,1),ds(t,n,i++,e,2,o,s,c,u,1),ds(t,n,i++,e,3,o,s,d,m,1)}o=s,l=a,h=r,c=u,d=m}i.push(n);break}case Is:{let s=t.readInt(!0),n=new wt(a,s,e),o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255;for(let e=0,i=0;n.setFrame(e,o,l,h,c),e!=r;e++){let s=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255;switch(t.readByte()){case qs:n.setStepped(e);break;case Ws:ds(t,n,i++,e,0,o,s,l,a,1),ds(t,n,i++,e,1,o,s,h,r,1),ds(t,n,i++,e,2,o,s,c,d,1)}o=s,l=a,h=r,c=d}i.push(n);break}case Cs:{let s=t.readInt(!0),n=new kt(a,s,e),o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255,f=t.readUnsignedByte()/255;for(let e=0,i=0;n.setFrame(e,o,l,h,c,d,u,m,f),e!=r;e++){let s=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,g=t.readUnsignedByte()/255,p=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255,x=t.readUnsignedByte()/255,w=t.readUnsignedByte()/255;switch(t.readByte()){case qs:n.setStepped(e);break;case Ws:ds(t,n,i++,e,0,o,s,l,a,1),ds(t,n,i++,e,1,o,s,h,r,1),ds(t,n,i++,e,2,o,s,c,g,1),ds(t,n,i++,e,3,o,s,d,p,1),ds(t,n,i++,e,4,o,s,u,b,1),ds(t,n,i++,e,5,o,s,m,x,1),ds(t,n,i++,e,6,o,s,f,w,1)}o=s,l=a,h=r,c=g,d=p,u=b,m=x,f=w}i.push(n);break}case Ms:{let s=t.readInt(!0),n=new vt(a,s,e),o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255;for(let e=0,i=0;n.setFrame(e,o,l,h,c,d,u,m),e!=r;e++){let s=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,f=t.readUnsignedByte()/255,g=t.readUnsignedByte()/255,p=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255;switch(t.readByte()){case qs:n.setStepped(e);break;case Ws:ds(t,n,i++,e,0,o,s,l,a,1),ds(t,n,i++,e,1,o,s,h,r,1),ds(t,n,i++,e,2,o,s,c,f,1),ds(t,n,i++,e,3,o,s,d,g,1),ds(t,n,i++,e,4,o,s,u,p,1),ds(t,n,i++,e,5,o,s,m,b,1)}o=s,l=a,h=r,c=f,d=g,u=p,m=b}i.push(n);break}case Fs:{let s=new yt(a,t.readInt(!0),e),n=t.readFloat(),o=t.readUnsignedByte()/255;for(let e=0,i=0;s.setFrame(e,n,o),e!=r;e++){let a=t.readFloat(),r=t.readUnsignedByte()/255;switch(t.readByte()){case qs:s.setStepped(e);break;case Ws:ds(t,s,i++,e,0,n,a,o,r,1)}n=a,o=r}i.push(s)}}}}for(let l=0,h=t.readInt(!0);l<h;l++){let e=t.readInt(!0);for(let s=0,r=t.readInt(!0);s<r;s++){let s=t.readByte(),r=t.readInt(!0);if(s==vs){let s=new bt(r,e);for(let e=0;e<r;e++)s.setFrame(e,t.readFloat(),t.readByte());i.push(s);continue}let n=t.readInt(!0);switch(s){case us:i.push(hs(t,new ot(r,n,e),1));break;case ms:i.push(cs(t,new lt(r,n,e),a));break;case fs:i.push(hs(t,new ht(r,n,e),a));break;case gs:i.push(hs(t,new ct(r,n,e),a));break;case ps:i.push(cs(t,new dt(r,n,e),1));break;case bs:i.push(hs(t,new ut(r,n,e),1));break;case xs:i.push(hs(t,new mt(r,n,e),1));break;case ws:i.push(cs(t,new ft(r,n,e),1));break;case ys:i.push(hs(t,new gt(r,n,e),1));break;case ks:i.push(hs(t,new pt(r,n,e),1))}}}for(let l=0,h=t.readInt(!0);l<h;l++){let e=t.readInt(!0),s=t.readInt(!0),r=s-1,n=new Yt(s,t.readInt(!0),e),o=t.readByte(),l=t.readFloat(),h=1&o?2&o?t.readFloat():1:0,c=4&o?t.readFloat()*a:0;for(let i=0,d=0;n.setFrame(i,l,h,c,8&o?1:-1,!!(16&o),!!(32&o)),i!=r;i++){o=t.readByte();const e=t.readFloat(),s=1&o?2&o?t.readFloat():1:0,r=4&o?t.readFloat()*a:0;64&o?n.setStepped(i):128&o&&(ds(t,n,d++,i,0,l,e,h,s,1),ds(t,n,d++,i,1,l,e,c,r,a)),l=e,h=s,c=r}i.push(n)}for(let l=0,h=t.readInt(!0);l<h;l++){let e=t.readInt(!0),s=t.readInt(!0),a=s-1,r=new Tt(s,t.readInt(!0),e),n=t.readFloat(),o=t.readFloat(),l=t.readFloat(),h=t.readFloat(),c=t.readFloat(),d=t.readFloat(),u=t.readFloat();for(let i=0,m=0;r.setFrame(i,n,o,l,h,c,d,u),i!=a;i++){let e=t.readFloat(),s=t.readFloat(),a=t.readFloat(),f=t.readFloat(),g=t.readFloat(),p=t.readFloat(),b=t.readFloat();switch(t.readByte()){case qs:r.setStepped(i);break;case Ws:ds(t,r,m++,i,0,n,e,o,s,1),ds(t,r,m++,i,1,n,e,l,a,1),ds(t,r,m++,i,2,n,e,h,f,1),ds(t,r,m++,i,3,n,e,c,g,1),ds(t,r,m++,i,4,n,e,d,p,1),ds(t,r,m++,i,5,n,e,u,b,1)}n=e,o=s,l=a,h=f,c=g,d=p,u=b}i.push(r)}for(let l=0,h=t.readInt(!0);l<h;l++){let e=t.readInt(!0),r=s.pathConstraints[e];for(let s=0,n=t.readInt(!0);s<n;s++){const s=t.readByte(),n=t.readInt(!0),o=t.readInt(!0);switch(s){case Xs:i.push(hs(t,new Xt(n,o,e),r.positionMode==Me.Fixed?a:1));break;case Rs:i.push(hs(t,new Rt(n,o,e),r.spacingMode==Ye.Length||r.spacingMode==Ye.Fixed?a:1));break;case Ps:let s=new Pt(n,o,e),l=t.readFloat(),h=t.readFloat(),c=t.readFloat(),d=t.readFloat();for(let e=0,i=0,a=s.getFrameCount()-1;s.setFrame(e,l,h,c,d),e!=a;e++){let a=t.readFloat(),r=t.readFloat(),n=t.readFloat(),o=t.readFloat();switch(t.readByte()){case qs:s.setStepped(e);break;case Ws:ds(t,s,i++,e,0,l,a,h,r,1),ds(t,s,i++,e,1,l,a,c,n,1),ds(t,s,i++,e,2,l,a,d,o,1)}l=a,h=r,c=n,d=o}i.push(s)}}}for(let l=0,h=t.readInt(!0);l<h;l++){const e=t.readInt(!0)-1;for(let s=0,a=t.readInt(!0);s<a;s++){const s=t.readByte(),a=t.readInt(!0);if(s==Ls){const s=new Wt(a,e);for(let e=0;e<a;e++)s.setFrame(e,t.readFloat());i.push(s);continue}const r=t.readInt(!0);switch(s){case Es:i.push(hs(t,new Bt(a,r,e),1));break;case Bs:i.push(hs(t,new Vt(a,r,e),1));break;case Vs:i.push(hs(t,new Dt(a,r,e),1));break;case Ds:i.push(hs(t,new _t(a,r,e),1));break;case _s:i.push(hs(t,new Nt(a,r,e),1));break;case Ns:i.push(hs(t,new Ot(a,r,e),1));break;case Os:i.push(hs(t,new Lt(a,r,e),1))}}}for(let l=0,h=t.readInt(!0);l<h;l++){let e=s.skins[t.readInt(!0)];for(let s=0,r=t.readInt(!0);s<r;s++){let s=t.readInt(!0);for(let r=0,n=t.readInt(!0);r<n;r++){let r=t.readStringRef();if(!r)throw new Error("attachmentName must not be null.");let n=e.getAttachment(s,r),o=t.readByte(),l=t.readInt(!0),h=l-1;switch(o){case Ys:{let e=n,r=e.bones,o=e.vertices,c=r?o.length/3*2:o.length,d=t.readInt(!0),u=new St(l,d,s,e),m=t.readFloat();for(let s=0,i=0;;s++){let e,n=t.readInt(!0);if(0==n)e=r?O.newFloatArray(c):o;else{e=O.newFloatArray(c);let s=t.readInt(!0);if(n+=s,1==a)for(let i=s;i<n;i++)e[i]=t.readFloat();else for(let i=s;i<n;i++)e[i]=t.readFloat()*a;if(!r)for(let t=0,i=e.length;t<i;t++)e[t]+=o[t]}if(u.setFrame(s,m,e),s==h)break;let l=t.readFloat();switch(t.readByte()){case qs:u.setStepped(s);break;case Ws:ds(t,u,i++,s,0,m,l,0,1,1)}m=l}i.push(u);break}case Ts:{let e=new zt(l,s,n);for(let s=0;s<l;s++){let i=t.readFloat(),a=t.readInt32();e.setFrame(s,i,K[15&a],a>>4,t.readFloat())}i.push(e);break}}}}}let r=t.readInt(!0);if(r>0){let e=new Ft(r),a=s.slots.length;for(let s=0;s<r;s++){let i=t.readFloat(),r=t.readInt(!0),n=O.newArray(a,0);for(let t=a-1;t>=0;t--)n[t]=-1;let o=O.newArray(a-r,0),l=0,h=0;for(let e=0;e<r;e++){let e=t.readInt(!0);for(;l!=e;)o[h++]=l++;n[l+t.readInt(!0)]=l++}for(;l<a;)o[h++]=l++;for(let t=a-1;t>=0;t--)-1==n[t]&&(n[t]=o[--h]);e.setFrame(s,i,n)}i.push(e)}let n=t.readInt(!0);if(n>0){let e=new Ct(n);for(let i=0;i<n;i++){let a=t.readFloat(),r=s.events[t.readInt(!0)],n=new Be(a,r);n.intValue=t.readInt(!1),n.floatValue=t.readFloat(),n.stringValue=t.readString(),null==n.stringValue&&(n.stringValue=r.stringValue),n.data.audioPath&&(n.volume=t.readFloat(),n.balance=t.readFloat()),e.setFrame(i,n)}i.push(e)}let o=0;for(let l=0,h=i.length;l<h;l++)o=Math.max(o,i[l].getDuration());return new Q(e,i,o)}}class as{constructor(t,s=new Array,i=0,a=new DataView(t instanceof ArrayBuffer?t:t.buffer)){e(this,"strings"),e(this,"index"),e(this,"buffer"),this.strings=s,this.index=i,this.buffer=a}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){let t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){let t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=127&e;return 128&e&&(e=this.readByte(),s|=(127&e)<<7,128&e&&(e=this.readByte(),s|=(127&e)<<14,128&e&&(e=this.readByte(),s|=(127&e)<<21,128&e&&(e=this.readByte(),s|=(127&e)<<28)))),t?s:s>>>1^-(1&s)}readStringRef(){let t=this.readInt(!0);return 0==t?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){let t=this.readUnsignedByte();switch(t>>4){case 12:case 13:e+=String.fromCharCode((31&t)<<6|63&this.readByte()),s+=2;break;case 14:e+=String.fromCharCode((15&t)<<12|(63&this.readByte())<<6|63&this.readByte()),s+=3;break;default:e+=String.fromCharCode(t),s++}}return e}readFloat(){let t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return 0!=this.readByte()}}let rs=class{constructor(t,s,i,a,r){e(this,"parent"),e(this,"skinIndex"),e(this,"slotIndex"),e(this,"mesh"),e(this,"inheritTimeline"),this.mesh=t,this.skinIndex=s,this.slotIndex=i,this.parent=a,this.inheritTimeline=r}};class ns{constructor(t=null,s=null,i=0){e(this,"bones"),e(this,"vertices"),e(this,"length"),this.bones=t,this.vertices=s,this.length=i}}var os,ls;function hs(t,e,s){let i=t.readFloat(),a=t.readFloat()*s;for(let r=0,n=0,o=e.getFrameCount()-1;e.setFrame(r,i,a),r!=o;r++){let o=t.readFloat(),l=t.readFloat()*s;switch(t.readByte()){case qs:e.setStepped(r);break;case Ws:ds(t,e,n++,r,0,i,o,a,l,s)}i=o,a=l}return e}function cs(t,e,s){let i=t.readFloat(),a=t.readFloat()*s,r=t.readFloat()*s;for(let n=0,o=0,l=e.getFrameCount()-1;e.setFrame(n,i,a,r),n!=l;n++){let l=t.readFloat(),h=t.readFloat()*s,c=t.readFloat()*s;switch(t.readByte()){case qs:e.setStepped(n);break;case Ws:ds(t,e,o++,n,0,i,l,a,h,s),ds(t,e,o++,n,1,i,l,r,c,s)}i=l,a=h,r=c}return e}function ds(t,e,s,i,a,r,n,o,l,h){e.setBezier(s,i,a,r,o,t.readFloat(),t.readFloat()*h,t.readFloat(),t.readFloat()*h,n,l)}(ls=os||(os={}))[ls.Region=0]="Region",ls[ls.BoundingBox=1]="BoundingBox",ls[ls.Mesh=2]="Mesh",ls[ls.LinkedMesh=3]="LinkedMesh",ls[ls.Path=4]="Path",ls[ls.Point=5]="Point",ls[ls.Clipping=6]="Clipping";const us=0,ms=1,fs=2,gs=3,ps=4,bs=5,xs=6,ws=7,ys=8,ks=9,vs=10,As=0,Ss=1,Is=2,Cs=3,Ms=4,Fs=5,Ys=0,Ts=1,Xs=0,Rs=1,Ps=2,Es=0,Bs=1,Vs=2,Ds=4,_s=5,Ns=6,Os=7,Ls=8,qs=1,Ws=2;class Us{constructor(){e(this,"minX",0),e(this,"minY",0),e(this,"maxX",0),e(this,"maxY",0),e(this,"boundingBoxes",new Array),e(this,"polygons",new Array),e(this,"polygonPool",new L(()=>O.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");let s=this.boundingBoxes,i=this.polygons,a=this.polygonPool,r=t.slots,n=r.length;s.length=0,a.freeAll(i),i.length=0;for(let o=0;o<n;o++){let t=r[o];if(!t.bone.active)continue;let e=t.getAttachment();if(e instanceof ne){let r=e;s.push(r);let n=a.obtain();n.length!=r.worldVerticesLength&&(n=O.newFloatArray(r.worldVerticesLength)),i.push(n),r.computeWorldVertices(t,0,r.worldVerticesLength,n,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY,a=this.polygons;for(let r=0,n=a.length;r<n;r++){let n=a[r],o=n;for(let a=0,r=n.length;a<r;a+=2){let r=o[a],n=o[a+1];t=Math.min(t,r),e=Math.min(e,n),s=Math.max(s,r),i=Math.max(i,n)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=i}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,i){let a=this.minX,r=this.minY,n=this.maxX,o=this.maxY;if(t<=a&&s<=a||e<=r&&i<=r||t>=n&&s>=n||e>=o&&i>=o)return!1;let l=(i-e)/(s-t),h=l*(a-t)+e;if(h>r&&h<o)return!0;if(h=l*(n-t)+e,h>r&&h<o)return!0;let c=(r-e)/l+t;return c>a&&c<n||(c=(o-e)/l+t,c>a&&c<n)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){let s=this.polygons;for(let i=0,a=s.length;i<a;i++)if(this.containsPointPolygon(s[i],t,e))return this.boundingBoxes[i];return null}containsPointPolygon(t,e,s){let i=t,a=t.length,r=a-2,n=!1;for(let o=0;o<a;o+=2){let t=i[o+1],a=i[r+1];if(t<s&&a>=s||a<s&&t>=s){let l=i[o];l+(s-t)/(a-t)*(i[r]-l)<e&&(n=!n)}r=o}return n}intersectsSegment(t,e,s,i){let a=this.polygons;for(let r=0,n=a.length;r<n;r++)if(this.intersectsSegmentPolygon(a[r],t,e,s,i))return this.boundingBoxes[r];return null}intersectsSegmentPolygon(t,e,s,i,a){let r=t,n=t.length,o=e-i,l=s-a,h=e*a-s*i,c=r[n-2],d=r[n-1];for(let u=0;u<n;u+=2){let t=r[u],n=r[u+1],m=c*n-d*t,f=c-t,g=d-n,p=o*g-l*f,b=(h*f-o*m)/p;if((b>=c&&b<=t||b>=t&&b<=c)&&(b>=e&&b<=i||b>=i&&b<=e)){let t=(h*g-l*m)/p;if((t>=d&&t<=n||t>=n&&t<=d)&&(t>=s&&t<=a||t>=a&&t<=s))return!0}c=t,d=n}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");let e=this.boundingBoxes.indexOf(t);return-1==e?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}class zs{constructor(){e(this,"convexPolygons",new Array),e(this,"convexPolygonsIndices",new Array),e(this,"indicesArray",new Array),e(this,"isConcaveArray",new Array),e(this,"triangles",new Array),e(this,"polygonPool",new L(()=>new Array)),e(this,"polygonIndicesPool",new L(()=>new Array))}triangulate(t){let e=t,s=t.length>>1,i=this.indicesArray;i.length=0;for(let n=0;n<s;n++)i[n]=n;let a=this.isConcaveArray;a.length=0;for(let n=0,o=s;n<o;++n)a[n]=zs.isConcave(n,s,e,i);let r=this.triangles;for(r.length=0;s>3;){let t=s-1,n=0,o=1;for(;;){t:if(!a[n]){let r=i[t]<<1,l=i[n]<<1,h=i[o]<<1,c=e[r],d=e[r+1],u=e[l],m=e[l+1],f=e[h],g=e[h+1];for(let n=(o+1)%s;n!=t;n=(n+1)%s){if(!a[n])continue;let t=i[n]<<1,s=e[t],r=e[t+1];if(zs.positiveArea(f,g,c,d,s,r)&&zs.positiveArea(c,d,u,m,s,r)&&zs.positiveArea(u,m,f,g,s,r))break t}break}if(0==o){do{if(!a[n])break;n--}while(n>0);break}t=n,n=o,o=(o+1)%s}r.push(i[(s+n-1)%s]),r.push(i[n]),r.push(i[(n+1)%s]),i.splice(n,1),a.splice(n,1),s--;let l=(s+n-1)%s,h=n==s?0:n;a[l]=zs.isConcave(l,s,e,i),a[h]=zs.isConcave(h,s,e,i)}return 3==s&&(r.push(i[2]),r.push(i[0]),r.push(i[1])),r}decompose(t,e){let s=t,i=this.convexPolygons;this.polygonPool.freeAll(i),i.length=0;let a=this.convexPolygonsIndices;this.polygonIndicesPool.freeAll(a),a.length=0;let r=this.polygonIndicesPool.obtain();r.length=0;let n=this.polygonPool.obtain();n.length=0;let o=-1,l=0;for(let h=0,c=e.length;h<c;h+=3){let t=e[h]<<1,c=e[h+1]<<1,d=e[h+2]<<1,u=s[t],m=s[t+1],f=s[c],g=s[c+1],p=s[d],b=s[d+1],x=!1;if(o==t){let t=n.length-4,e=zs.winding(n[t],n[t+1],n[t+2],n[t+3],p,b),s=zs.winding(p,b,n[0],n[1],n[2],n[3]);e==l&&s==l&&(n.push(p),n.push(b),r.push(d),x=!0)}x||(n.length>0?(i.push(n),a.push(r)):(this.polygonPool.free(n),this.polygonIndicesPool.free(r)),n=this.polygonPool.obtain(),n.length=0,n.push(u),n.push(m),n.push(f),n.push(g),n.push(p),n.push(b),r=this.polygonIndicesPool.obtain(),r.length=0,r.push(t),r.push(c),r.push(d),l=zs.winding(u,m,f,g,p,b),o=t)}n.length>0&&(i.push(n),a.push(r));for(let h=0,c=i.length;h<c;h++){if(r=a[h],0==r.length)continue;let t=r[0],e=r[r.length-1];n=i[h];let s=n.length-4,o=n[s],l=n[s+1],d=n[s+2],u=n[s+3],m=n[0],f=n[1],g=n[2],p=n[3],b=zs.winding(o,l,d,u,m,f);for(let x=0;x<c;x++){if(x==h)continue;let s=a[x];if(3!=s.length)continue;let c=s[0],w=s[1],y=s[2],k=i[x],v=k[k.length-2],A=k[k.length-1];if(c!=t||w!=e)continue;let S=zs.winding(o,l,d,u,v,A),I=zs.winding(v,A,m,f,g,p);S==b&&I==b&&(k.length=0,s.length=0,n.push(v),n.push(A),r.push(y),o=d,l=u,d=v,u=A,x=0)}}for(let h=i.length-1;h>=0;h--)n=i[h],0==n.length&&(i.splice(h,1),this.polygonPool.free(n),r=a[h],a.splice(h,1),this.polygonIndicesPool.free(r));return i}static isConcave(t,e,s,i){let a=i[(e+t-1)%e]<<1,r=i[t]<<1,n=i[(t+1)%e]<<1;return!this.positiveArea(s[a],s[a+1],s[r],s[r+1],s[n],s[n+1])}static positiveArea(t,e,s,i,a,r){return t*(r-i)+s*(e-r)+a*(i-e)>=0}static winding(t,e,s,i,a,r){let n=s-t,o=i-e;return a*o-r*n+n*e-t*o>=0?1:-1}}class js{constructor(){e(this,"triangulator",new zs),e(this,"clippingPolygon",new Array),e(this,"clipOutput",new Array),e(this,"clippedVertices",new Array),e(this,"clippedUVs",new Array),e(this,"clippedTriangles",new Array),e(this,"scratch",new Array),e(this,"clipAttachment",null),e(this,"clippingPolygons",null)}clipStart(t,e){if(this.clipAttachment)return 0;this.clipAttachment=e;let s=e.worldVerticesLength,i=O.setArraySize(this.clippingPolygon,s);e.computeWorldVertices(t,0,s,i,0,2);let a=this.clippingPolygon;js.makeClockwise(a);let r=this.clippingPolygons=this.triangulator.decompose(a,this.triangulator.triangulate(a));for(let n=0,o=r.length;n<o;n++){let t=r[n];js.makeClockwise(t),t.push(t[0]),t.push(t[1])}return r.length}clipEndWithSlot(t){this.clipAttachment&&this.clipAttachment.endSlot==t.data&&this.clipEnd()}clipEnd(){this.clipAttachment&&(this.clipAttachment=null,this.clippingPolygons=null,this.clippedVertices.length=0,this.clippedTriangles.length=0,this.clippingPolygon.length=0)}isClipping(){return null!=this.clipAttachment}clipTriangles(t,e,s,i,a,r,n,o){let l,h,c,d,u,m;"number"==typeof e?(l=s,h=i,c=a,d=r,u=n,m=o):(l=e,h=s,c=i,d=a,u=r,m=n),c&&d&&u&&"boolean"==typeof m?this.clipTrianglesRender(t,l,h,c,d,u,m):this.clipTrianglesNoRender(t,l,h)}clipTrianglesNoRender(t,e,s){let i=this.clipOutput,a=this.clippedVertices,r=this.clippedTriangles,n=this.clippingPolygons,o=n.length,l=0;a.length=0,r.length=0;for(let h=0;h<s;h+=3){let s=e[h]<<1,c=t[s],d=t[s+1];s=e[h+1]<<1;let u=t[s],m=t[s+1];s=e[h+2]<<1;let f=t[s],g=t[s+1];for(let t=0;t<o;t++){let e=a.length;if(!this.clip(c,d,u,m,f,g,n[t],i)){let t=O.setArraySize(a,e+6);t[e]=c,t[e+1]=d,t[e+2]=u,t[e+3]=m,t[e+4]=f,t[e+5]=g,e=r.length;let s=O.setArraySize(r,e+3);s[e]=l,s[e+1]=l+1,s[e+2]=l+2,l+=3;break}{let t=i.length;if(0==t)continue;let s=t>>1,n=this.clipOutput,o=O.setArraySize(a,e+2*s);for(let i=0;i<t;i+=2,e+=2){let t=n[i],s=n[i+1];o[e]=t,o[e+1]=s}e=r.length;let h=O.setArraySize(r,e+3*(s-2));s--;for(let i=1;i<s;i++,e+=3)h[e]=l,h[e+1]=l+i,h[e+2]=l+i+1;l+=s+1}}}}clipTrianglesRender(t,e,s,i,a,r,n){let o=this.clipOutput,l=this.clippedVertices,h=this.clippedTriangles,c=this.clippingPolygons,d=c.length,u=n?12:8,m=0;l.length=0,h.length=0;for(let f=0;f<s;f+=3){let s=e[f]<<1,g=t[s],p=t[s+1],b=i[s],x=i[s+1];s=e[f+1]<<1;let w=t[s],y=t[s+1],k=i[s],v=i[s+1];s=e[f+2]<<1;let A=t[s],S=t[s+1],I=i[s],C=i[s+1];for(let t=0;t<d;t++){let e=l.length;if(!this.clip(g,p,w,y,A,S,c[t],o)){let t=O.setArraySize(l,e+3*u);t[e]=g,t[e+1]=p,t[e+2]=a.r,t[e+3]=a.g,t[e+4]=a.b,t[e+5]=a.a,n?(t[e+6]=b,t[e+7]=x,t[e+8]=r.r,t[e+9]=r.g,t[e+10]=r.b,t[e+11]=r.a,t[e+12]=w,t[e+13]=y,t[e+14]=a.r,t[e+15]=a.g,t[e+16]=a.b,t[e+17]=a.a,t[e+18]=k,t[e+19]=v,t[e+20]=r.r,t[e+21]=r.g,t[e+22]=r.b,t[e+23]=r.a,t[e+24]=A,t[e+25]=S,t[e+26]=a.r,t[e+27]=a.g,t[e+28]=a.b,t[e+29]=a.a,t[e+30]=I,t[e+31]=C,t[e+32]=r.r,t[e+33]=r.g,t[e+34]=r.b,t[e+35]=r.a):(t[e+6]=b,t[e+7]=x,t[e+8]=w,t[e+9]=y,t[e+10]=a.r,t[e+11]=a.g,t[e+12]=a.b,t[e+13]=a.a,t[e+14]=k,t[e+15]=v,t[e+16]=A,t[e+17]=S,t[e+18]=a.r,t[e+19]=a.g,t[e+20]=a.b,t[e+21]=a.a,t[e+22]=I,t[e+23]=C),e=h.length;let s=O.setArraySize(h,e+3);s[e]=m,s[e+1]=m+1,s[e+2]=m+2,m+=3;break}{let t=o.length;if(0==t)continue;let s=y-S,i=A-w,c=g-A,d=S-p,f=1/(s*c+i*(p-S)),M=t>>1,F=this.clipOutput,Y=O.setArraySize(l,e+M*u);for(let o=0;o<t;o+=2,e+=u){let t=F[o],l=F[o+1];Y[e]=t,Y[e+1]=l,Y[e+2]=a.r,Y[e+3]=a.g,Y[e+4]=a.b,Y[e+5]=a.a;let h=t-A,u=l-S,m=(s*h+i*u)*f,g=(d*h+c*u)*f,p=1-m-g;Y[e+6]=b*m+k*g+I*p,Y[e+7]=x*m+v*g+C*p,n&&(Y[e+8]=r.r,Y[e+9]=r.g,Y[e+10]=r.b,Y[e+11]=r.a)}e=h.length;let T=O.setArraySize(h,e+3*(M-2));M--;for(let a=1;a<M;a++,e+=3)T[e]=m,T[e+1]=m+a,T[e+2]=m+a+1;m+=M+1}}}}clipTrianglesUnpacked(t,e,s,i){let a=this.clipOutput,r=this.clippedVertices,n=this.clippedUVs,o=this.clippedTriangles,l=this.clippingPolygons,h=l.length,c=0;r.length=0,n.length=0,o.length=0;for(let d=0;d<s;d+=3){let s=e[d]<<1,u=t[s],m=t[s+1],f=i[s],g=i[s+1];s=e[d+1]<<1;let p=t[s],b=t[s+1],x=i[s],w=i[s+1];s=e[d+2]<<1;let y=t[s],k=t[s+1],v=i[s],A=i[s+1];for(let t=0;t<h;t++){let e=r.length;if(!this.clip(u,m,p,b,y,k,l[t],a)){let t=O.setArraySize(r,e+6);t[e]=u,t[e+1]=m,t[e+2]=p,t[e+3]=b,t[e+4]=y,t[e+5]=k;let s=O.setArraySize(n,e+6);s[e]=f,s[e+1]=g,s[e+2]=x,s[e+3]=w,s[e+4]=v,s[e+5]=A,e=o.length;let i=O.setArraySize(o,e+3);i[e]=c,i[e+1]=c+1,i[e+2]=c+2,c+=3;break}{let t=a.length;if(0==t)continue;let s=b-k,i=y-p,l=u-y,h=k-m,d=1/(s*l+i*(m-k)),S=t>>1,I=this.clipOutput,C=O.setArraySize(r,e+2*S),M=O.setArraySize(n,e+2*S);for(let a=0;a<t;a+=2,e+=2){let t=I[a],r=I[a+1];C[e]=t,C[e+1]=r;let n=t-y,o=r-k,c=(s*n+i*o)*d,u=(h*n+l*o)*d,m=1-c-u;M[e]=f*c+x*u+v*m,M[e+1]=g*c+w*u+A*m}e=o.length;let F=O.setArraySize(o,e+3*(S-2));S--;for(let a=1;a<S;a++,e+=3)F[e]=c,F[e+1]=c+a,F[e+2]=c+a+1;c+=S+1}}}}clip(t,e,s,i,a,r,n,o){let l,h=o,c=!1;n.length%4>=2?(l=o,o=this.scratch):l=this.scratch,l.length=0,l.push(t),l.push(e),l.push(s),l.push(i),l.push(a),l.push(r),l.push(t),l.push(e),o.length=0;let d=n.length-4,u=n;for(let m=0;;m+=2){let t=u[m],e=u[m+1],s=t-u[m+2],i=e-u[m+3],a=o.length,r=l;for(let h=0,d=l.length-2;h<d;){let a=r[h],n=r[h+1];h+=2;let l=r[h],d=r[h+1],u=i*(t-l)>s*(e-d),m=i*(t-a)-s*(e-n);if(m>0){if(u){o.push(l),o.push(d);continue}let t=l-a,e=d-n,r=m/(t*i-e*s);if(!(r>=0&&r<=1)){o.push(l),o.push(d);continue}o.push(a+t*r),o.push(n+e*r)}else if(u){let t=l-a,e=d-n,r=m/(t*i-e*s);if(!(r>=0&&r<=1)){o.push(l),o.push(d);continue}o.push(a+t*r),o.push(n+e*r),o.push(l),o.push(d)}c=!0}if(a==o.length)return h.length=0,!0;if(o.push(o[0]),o.push(o[1]),m==d)break;let n=o;(o=l).length=0,l=n}if(h!=o){h.length=0;for(let t=0,e=o.length-2;t<e;t++)h[t]=o[t]}else h.length=h.length-2;return c}static makeClockwise(t){let e=t,s=t.length,i=e[s-2]*e[1]-e[0]*e[s-1],a=0,r=0,n=0,o=0;for(let l=0,h=s-3;l<h;l+=2)a=e[l],r=e[l+1],n=e[l+2],o=e[l+3],i+=a*o-n*r;if(!(i<0))for(let l=0,h=s-2,c=s>>1;l<c;l+=2){let t=e[l],s=e[l+1],i=h-l;e[l]=e[i],e[l+1]=e[i+1],e[i]=t,e[i+1]=s}}}class Gs{constructor(t){e(this,"attachmentLoader"),e(this,"scale",1),e(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){let e=this.scale,s=new Je,i="string"==typeof t?JSON.parse(t):t,a=i.skeleton;if(a&&(s.hash=a.hash,s.version=a.spine,s.x=a.x,s.y=a.y,s.width=a.width,s.height=a.height,s.referenceScale=Js(a,"referenceScale",100)*e,s.fps=a.fps,s.imagesPath=a.images??null,s.audioPath=a.audio??null),i.bones)for(let r=0;r<i.bones.length;r++){let t=i.bones[r],a=null,n=Js(t,"parent",null);n&&(a=s.findBone(n));let o=new Se(s.bones.length,t.name,a);o.length=Js(t,"length",0)*e,o.x=Js(t,"x",0)*e,o.y=Js(t,"y",0)*e,o.rotation=Js(t,"rotation",0),o.scaleX=Js(t,"scaleX",1),o.scaleY=Js(t,"scaleY",1),o.shearX=Js(t,"shearX",0),o.shearY=Js(t,"shearY",0),o.inherit=O.enumValue(Ie,Js(t,"inherit","Normal")),o.skinRequired=Js(t,"skin",!1);let l=Js(t,"color",null);l&&o.color.setFromString(l),s.bones.push(o)}if(i.slots)for(let r=0;r<i.slots.length;r++){let t=i.slots[r],e=t.name,a=s.findBone(t.bone);if(!a)throw new Error(`Couldn't find bone ${t.bone} for slot ${e}`);let n=new es(s.slots.length,e,a),o=Js(t,"color",null);o&&n.color.setFromString(o);let l=Js(t,"dark",null);l&&(n.darkColor=V.fromString(l)),n.attachmentName=Js(t,"attachment",null),n.blendMode=O.enumValue(He,Js(t,"blend","normal")),n.visible=Js(t,"visible",!0),s.slots.push(n)}if(i.ik)for(let r=0;r<i.ik.length;r++){let t=i.ik[r],a=new _e(t.name);a.order=Js(t,"order",0),a.skinRequired=Js(t,"skin",!1);for(let e=0;e<t.bones.length;e++){let i=s.findBone(t.bones[e]);if(!i)throw new Error(`Couldn't find bone ${t.bones[e]} for IK constraint ${t.name}.`);a.bones.push(i)}let n=s.findBone(t.target);if(!n)throw new Error(`Couldn't find target bone ${t.target} for IK constraint ${t.name}.`);a.target=n,a.mix=Js(t,"mix",1),a.softness=Js(t,"softness",0)*e,a.bendDirection=Js(t,"bendPositive",!0)?1:-1,a.compress=Js(t,"compress",!1),a.stretch=Js(t,"stretch",!1),a.uniform=Js(t,"uniform",!1),s.ikConstraints.push(a)}if(i.transform)for(let r=0;r<i.transform.length;r++){let t=i.transform[r],a=new ss(t.name);a.order=Js(t,"order",0),a.skinRequired=Js(t,"skin",!1);for(let e=0;e<t.bones.length;e++){let i=t.bones[e],r=s.findBone(i);if(!r)throw new Error(`Couldn't find bone ${i} for transform constraint ${t.name}.`);a.bones.push(r)}let n=t.target,o=s.findBone(n);if(!o)throw new Error(`Couldn't find target bone ${n} for transform constraint ${t.name}.`);a.target=o,a.local=Js(t,"local",!1),a.relative=Js(t,"relative",!1),a.offsetRotation=Js(t,"rotation",0),a.offsetX=Js(t,"x",0)*e,a.offsetY=Js(t,"y",0)*e,a.offsetScaleX=Js(t,"scaleX",0),a.offsetScaleY=Js(t,"scaleY",0),a.offsetShearY=Js(t,"shearY",0),a.mixRotate=Js(t,"mixRotate",1),a.mixX=Js(t,"mixX",1),a.mixY=Js(t,"mixY",a.mixX),a.mixScaleX=Js(t,"mixScaleX",1),a.mixScaleY=Js(t,"mixScaleY",a.mixScaleX),a.mixShearY=Js(t,"mixShearY",1),s.transformConstraints.push(a)}if(i.path)for(let r=0;r<i.path.length;r++){let t=i.path[r],a=new Ne(t.name);a.order=Js(t,"order",0),a.skinRequired=Js(t,"skin",!1);for(let e=0;e<t.bones.length;e++){let i=t.bones[e],r=s.findBone(i);if(!r)throw new Error(`Couldn't find bone ${i} for path constraint ${t.name}.`);a.bones.push(r)}let n=t.target,o=s.findSlot(n);if(!o)throw new Error(`Couldn't find target slot ${n} for path constraint ${t.name}.`);a.target=o,a.positionMode=O.enumValue(Me,Js(t,"positionMode","Percent")),a.spacingMode=O.enumValue(Ye,Js(t,"spacingMode","Length")),a.rotateMode=O.enumValue(Xe,Js(t,"rotateMode","Tangent")),a.offsetRotation=Js(t,"rotation",0),a.position=Js(t,"position",0),a.positionMode==Me.Fixed&&(a.position*=e),a.spacing=Js(t,"spacing",0),a.spacingMode!=Ye.Length&&a.spacingMode!=Ye.Fixed||(a.spacing*=e),a.mixRotate=Js(t,"mixRotate",1),a.mixX=Js(t,"mixX",1),a.mixY=Js(t,"mixY",a.mixX),s.pathConstraints.push(a)}if(i.physics)for(let r=0;r<i.physics.length;r++){const t=i.physics[r],a=new Qe(t.name);a.order=Js(t,"order",0),a.skinRequired=Js(t,"skin",!1);const n=t.bone,o=s.findBone(n);if(null==o)throw new Error("Physics bone not found: "+n);a.bone=o,a.x=Js(t,"x",0),a.y=Js(t,"y",0),a.rotate=Js(t,"rotate",0),a.scaleX=Js(t,"scaleX",0),a.shearX=Js(t,"shearX",0),a.limit=Js(t,"limit",5e3)*e,a.step=1/Js(t,"fps",60),a.inertia=Js(t,"inertia",1),a.strength=Js(t,"strength",100),a.damping=Js(t,"damping",1),a.massInverse=1/Js(t,"mass",1),a.wind=Js(t,"wind",0),a.gravity=Js(t,"gravity",0),a.mix=Js(t,"mix",1),a.inertiaGlobal=Js(t,"inertiaGlobal",!1),a.strengthGlobal=Js(t,"strengthGlobal",!1),a.dampingGlobal=Js(t,"dampingGlobal",!1),a.massGlobal=Js(t,"massGlobal",!1),a.windGlobal=Js(t,"windGlobal",!1),a.gravityGlobal=Js(t,"gravityGlobal",!1),a.mixGlobal=Js(t,"mixGlobal",!1),s.physicsConstraints.push(a)}if(i.skins)for(let r=0;r<i.skins.length;r++){let t=i.skins[r],e=new ts(t.name);if(t.bones)for(let i=0;i<t.bones.length;i++){let a=t.bones[i],r=s.findBone(a);if(!r)throw new Error(`Couldn't find bone ${a} for skin ${t.name}.`);e.bones.push(r)}if(t.ik)for(let i=0;i<t.ik.length;i++){let a=t.ik[i],r=s.findIkConstraint(a);if(!r)throw new Error(`Couldn't find IK constraint ${a} for skin ${t.name}.`);e.constraints.push(r)}if(t.transform)for(let i=0;i<t.transform.length;i++){let a=t.transform[i],r=s.findTransformConstraint(a);if(!r)throw new Error(`Couldn't find transform constraint ${a} for skin ${t.name}.`);e.constraints.push(r)}if(t.path)for(let i=0;i<t.path.length;i++){let a=t.path[i],r=s.findPathConstraint(a);if(!r)throw new Error(`Couldn't find path constraint ${a} for skin ${t.name}.`);e.constraints.push(r)}if(t.physics)for(let i=0;i<t.physics.length;i++){let a=t.physics[i],r=s.findPhysicsConstraint(a);if(!r)throw new Error(`Couldn't find physics constraint ${a} for skin ${t.name}.`);e.constraints.push(r)}for(let i in t.attachments){let a=s.findSlot(i);if(!a)throw new Error(`Couldn't find slot ${i} for skin ${t.name}.`);let r=t.attachments[i];for(let t in r){let i=this.readAttachment(r[t],e,a.index,t,s);i&&e.setAttachment(a.index,t,i)}}s.skins.push(e),"default"==e.name&&(s.defaultSkin=e)}for(let r=0,n=this.linkedMeshes.length;r<n;r++){let t=this.linkedMeshes[r],e=t.skin?s.findSkin(t.skin):s.defaultSkin;if(!e)throw new Error(`Skin not found: ${t.skin}`);let i=e.getAttachment(t.slotIndex,t.parent);if(!i)throw new Error(`Parent mesh not found: ${t.parent}`);t.mesh.timelineAttachment=t.inheritTimeline?i:t.mesh,t.mesh.setParentMesh(i),null!=t.mesh.region&&t.mesh.updateRegion()}if(this.linkedMeshes.length=0,i.events)for(let r in i.events){let t=i.events[r],e=new Ve(r);e.intValue=Js(t,"int",0),e.floatValue=Js(t,"float",0),e.stringValue=Js(t,"string",""),e.audioPath=Js(t,"audio",null),e.audioPath&&(e.volume=Js(t,"volume",1),e.balance=Js(t,"balance",0)),s.events.push(e)}if(i.animations)for(let r in i.animations){let t=i.animations[r];this.readAnimation(t,r,s)}return s}readAttachment(t,e,s,i,a){let r=this.scale;switch(i=Js(t,"name",i),Js(t,"type","region")){case"region":{let s=Js(t,"path",i),a=this.readSequence(Js(t,"sequence",null)),n=this.attachmentLoader.newRegionAttachment(e,i,s,a);if(!n)return null;n.path=s,n.x=Js(t,"x",0)*r,n.y=Js(t,"y",0)*r,n.scaleX=Js(t,"scaleX",1),n.scaleY=Js(t,"scaleY",1),n.rotation=Js(t,"rotation",0),n.width=t.width*r,n.height=t.height*r,n.sequence=a;let o=Js(t,"color",null);return o&&n.color.setFromString(o),null!=n.region&&n.updateRegion(),n}case"boundingbox":{let s=this.attachmentLoader.newBoundingBoxAttachment(e,i);if(!s)return null;this.readVertices(t,s,t.vertexCount<<1);let a=Js(t,"color",null);return a&&s.color.setFromString(a),s}case"mesh":case"linkedmesh":{let a=Js(t,"path",i),n=this.readSequence(Js(t,"sequence",null)),o=this.attachmentLoader.newMeshAttachment(e,i,a,n);if(!o)return null;o.path=a;let l=Js(t,"color",null);l&&o.color.setFromString(l),o.width=Js(t,"width",0)*r,o.height=Js(t,"height",0)*r,o.sequence=n;let h=Js(t,"parent",null);if(h)return this.linkedMeshes.push(new $s(o,Js(t,"skin",null),s,h,Js(t,"timelines",!0))),o;let c=t.uvs;return this.readVertices(t,o,c.length),o.triangles=t.triangles,o.regionUVs=c,null!=o.region&&o.updateRegion(),o.edges=Js(t,"edges",null),o.hullLength=2*Js(t,"hull",0),o}case"path":{let s=this.attachmentLoader.newPathAttachment(e,i);if(!s)return null;s.closed=Js(t,"closed",!1),s.constantSpeed=Js(t,"constantSpeed",!0);let a=t.vertexCount;this.readVertices(t,s,a<<1);let n=O.newArray(a/3,0);for(let e=0;e<t.lengths.length;e++)n[e]=t.lengths[e]*r;s.lengths=n;let o=Js(t,"color",null);return o&&s.color.setFromString(o),s}case"point":{let s=this.attachmentLoader.newPointAttachment(e,i);if(!s)return null;s.x=Js(t,"x",0)*r,s.y=Js(t,"y",0)*r,s.rotation=Js(t,"rotation",0);let a=Js(t,"color",null);return a&&s.color.setFromString(a),s}case"clipping":{let s=this.attachmentLoader.newClippingAttachment(e,i);if(!s)return null;let r=Js(t,"end",null);r&&(s.endSlot=a.findSlot(r));let n=t.vertexCount;this.readVertices(t,s,n<<1);let o=Js(t,"color",null);return o&&s.color.setFromString(o),s}}return null}readSequence(t){if(null==t)return null;let e=new G(Js(t,"count",0));return e.start=Js(t,"start",1),e.digits=Js(t,"digits",0),e.setupIndex=Js(t,"setup",0),e}readVertices(t,e,s){let i=this.scale;e.worldVerticesLength=s;let a=t.vertices;if(s==a.length){let t=O.toFloatArray(a);if(1!=i)for(let e=0,s=a.length;e<s;e++)t[e]*=i;return void(e.vertices=t)}let r=new Array,n=new Array;for(let o=0,l=a.length;o<l;){let t=a[o++];n.push(t);for(let e=o+4*t;o<e;o+=4)n.push(a[o]),r.push(a[o+1]*i),r.push(a[o+2]*i),r.push(a[o+3])}e.bones=n,e.vertices=O.toFloatArray(r)}readAnimation(t,e,s){let i=this.scale,a=new Array;if(t.slots)for(let n in t.slots){let e=t.slots[n],i=s.findSlot(n);if(!i)throw new Error("Slot not found: "+n);let r=i.index;for(let t in e){let s=e[t];if(!s)continue;let i=s.length;if("attachment"==t){let t=new At(i,r);for(let e=0;e<i;e++){let i=s[e];t.setFrame(e,Js(i,"time",0),Js(i,"name",null))}a.push(t)}else if("rgba"==t){let t=new xt(i,i<<2,r),e=s[0],n=Js(e,"time",0),o=V.fromString(e.color);for(let i=0,a=0;;i++){t.setFrame(i,n,o.r,o.g,o.b,o.a);let r=s[i+1];if(!r){t.shrink(a);break}let l=Js(r,"time",0),h=V.fromString(r.color),c=e.curve;c&&(a=Qs(c,t,a,i,0,n,l,o.r,h.r,1),a=Qs(c,t,a,i,1,n,l,o.g,h.g,1),a=Qs(c,t,a,i,2,n,l,o.b,h.b,1),a=Qs(c,t,a,i,3,n,l,o.a,h.a,1)),n=l,o=h,e=r}a.push(t)}else if("rgb"==t){let t=new wt(i,3*i,r),e=s[0],n=Js(e,"time",0),o=V.fromString(e.color);for(let i=0,a=0;;i++){t.setFrame(i,n,o.r,o.g,o.b);let r=s[i+1];if(!r){t.shrink(a);break}let l=Js(r,"time",0),h=V.fromString(r.color),c=e.curve;c&&(a=Qs(c,t,a,i,0,n,l,o.r,h.r,1),a=Qs(c,t,a,i,1,n,l,o.g,h.g,1),a=Qs(c,t,a,i,2,n,l,o.b,h.b,1)),n=l,o=h,e=r}a.push(t)}else if("alpha"==t)a.push(Hs(s,new yt(i,i,r),0,1));else if("rgba2"==t){let t=new kt(i,7*i,r),e=s[0],n=Js(e,"time",0),o=V.fromString(e.light),l=V.fromString(e.dark);for(let i=0,a=0;;i++){t.setFrame(i,n,o.r,o.g,o.b,o.a,l.r,l.g,l.b);let r=s[i+1];if(!r){t.shrink(a);break}let h=Js(r,"time",0),c=V.fromString(r.light),d=V.fromString(r.dark),u=e.curve;u&&(a=Qs(u,t,a,i,0,n,h,o.r,c.r,1),a=Qs(u,t,a,i,1,n,h,o.g,c.g,1),a=Qs(u,t,a,i,2,n,h,o.b,c.b,1),a=Qs(u,t,a,i,3,n,h,o.a,c.a,1),a=Qs(u,t,a,i,4,n,h,l.r,d.r,1),a=Qs(u,t,a,i,5,n,h,l.g,d.g,1),a=Qs(u,t,a,i,6,n,h,l.b,d.b,1)),n=h,o=c,l=d,e=r}a.push(t)}else if("rgb2"==t){let t=new vt(i,6*i,r),e=s[0],n=Js(e,"time",0),o=V.fromString(e.light),l=V.fromString(e.dark);for(let i=0,a=0;;i++){t.setFrame(i,n,o.r,o.g,o.b,l.r,l.g,l.b);let r=s[i+1];if(!r){t.shrink(a);break}let h=Js(r,"time",0),c=V.fromString(r.light),d=V.fromString(r.dark),u=e.curve;u&&(a=Qs(u,t,a,i,0,n,h,o.r,c.r,1),a=Qs(u,t,a,i,1,n,h,o.g,c.g,1),a=Qs(u,t,a,i,2,n,h,o.b,c.b,1),a=Qs(u,t,a,i,3,n,h,l.r,d.r,1),a=Qs(u,t,a,i,4,n,h,l.g,d.g,1),a=Qs(u,t,a,i,5,n,h,l.b,d.b,1)),n=h,o=c,l=d,e=r}a.push(t)}}}if(t.bones)for(let n in t.bones){let e=t.bones[n],r=s.findBone(n);if(!r)throw new Error("Bone not found: "+n);let o=r.index;for(let t in e){let s=e[t],n=s.length;if(0!=n)if("rotate"===t)a.push(Hs(s,new ot(n,n,o),0,1));else if("translate"===t){let t=new lt(n,n<<1,o);a.push(Ks(s,t,"x","y",0,i))}else if("translatex"===t){let t=new ht(n,n,o);a.push(Hs(s,t,0,i))}else if("translatey"===t){let t=new ct(n,n,o);a.push(Hs(s,t,0,i))}else if("scale"===t){let t=new dt(n,n<<1,o);a.push(Ks(s,t,"x","y",1,1))}else if("scalex"===t){let t=new ut(n,n,o);a.push(Hs(s,t,1,1))}else if("scaley"===t){let t=new mt(n,n,o);a.push(Hs(s,t,1,1))}else if("shear"===t){let t=new ft(n,n<<1,o);a.push(Ks(s,t,"x","y",0,1))}else if("shearx"===t){let t=new gt(n,n,o);a.push(Hs(s,t,0,1))}else if("sheary"===t){let t=new pt(n,n,o);a.push(Hs(s,t,0,1))}else if("inherit"===t){let t=new bt(n,r.index);for(let e=0;e<s.length;e++){let i=s[e];t.setFrame(e,Js(i,"time",0),O.enumValue(Ie,Js(i,"inherit","Normal")))}a.push(t)}}}if(t.ik)for(let n in t.ik){let e=t.ik[n],r=e[0];if(!r)continue;let o=s.findIkConstraint(n);if(!o)throw new Error("IK Constraint not found: "+n);let l=s.ikConstraints.indexOf(o),h=new Yt(e.length,e.length<<1,l),c=Js(r,"time",0),d=Js(r,"mix",1),u=Js(r,"softness",0)*i;for(let t=0,s=0;;t++){h.setFrame(t,c,d,u,Js(r,"bendPositive",!0)?1:-1,Js(r,"compress",!1),Js(r,"stretch",!1));let a=e[t+1];if(!a){h.shrink(s);break}let n=Js(a,"time",0),o=Js(a,"mix",1),l=Js(a,"softness",0)*i,m=r.curve;m&&(s=Qs(m,h,s,t,0,c,n,d,o,1),s=Qs(m,h,s,t,1,c,n,u,l,i)),c=n,d=o,u=l,r=a}a.push(h)}if(t.transform)for(let n in t.transform){let e=t.transform[n],i=e[0];if(!i)continue;let r=s.findTransformConstraint(n);if(!r)throw new Error("Transform constraint not found: "+n);let o=s.transformConstraints.indexOf(r),l=new Tt(e.length,6*e.length,o),h=Js(i,"time",0),c=Js(i,"mixRotate",1),d=Js(i,"mixX",1),u=Js(i,"mixY",d),m=Js(i,"mixScaleX",1),f=Js(i,"mixScaleY",m),g=Js(i,"mixShearY",1);for(let t=0,s=0;;t++){l.setFrame(t,h,c,d,u,m,f,g);let a=e[t+1];if(!a){l.shrink(s);break}let r=Js(a,"time",0),n=Js(a,"mixRotate",1),o=Js(a,"mixX",1),p=Js(a,"mixY",o),b=Js(a,"mixScaleX",1),x=Js(a,"mixScaleY",b),w=Js(a,"mixShearY",1),y=i.curve;y&&(s=Qs(y,l,s,t,0,h,r,c,n,1),s=Qs(y,l,s,t,1,h,r,d,o,1),s=Qs(y,l,s,t,2,h,r,u,p,1),s=Qs(y,l,s,t,3,h,r,m,b,1),s=Qs(y,l,s,t,4,h,r,f,x,1),s=Qs(y,l,s,t,5,h,r,g,w,1)),h=r,c=n,d=o,u=p,m=b,f=x,m=b,i=a}a.push(l)}if(t.path)for(let n in t.path){let e=t.path[n],r=s.findPathConstraint(n);if(!r)throw new Error("Path constraint not found: "+n);let o=s.pathConstraints.indexOf(r);for(let t in e){let s=e[t],n=s[0];if(!n)continue;let l=s.length;if("position"===t){let t=new Xt(l,l,o);a.push(Hs(s,t,0,r.positionMode==Me.Fixed?i:1))}else if("spacing"===t){let t=new Rt(l,l,o);a.push(Hs(s,t,0,r.spacingMode==Ye.Length||r.spacingMode==Ye.Fixed?i:1))}else if("mix"===t){let t=new Pt(l,3*l,o),e=Js(n,"time",0),i=Js(n,"mixRotate",1),r=Js(n,"mixX",1),h=Js(n,"mixY",r);for(let a=0,o=0;;a++){t.setFrame(a,e,i,r,h);let l=s[a+1];if(!l){t.shrink(o);break}let c=Js(l,"time",0),d=Js(l,"mixRotate",1),u=Js(l,"mixX",1),m=Js(l,"mixY",u),f=n.curve;f&&(o=Qs(f,t,o,a,0,e,c,i,d,1),o=Qs(f,t,o,a,1,e,c,r,u,1),o=Qs(f,t,o,a,2,e,c,h,m,1)),e=c,i=d,r=u,h=m,n=l}a.push(t)}}}if(t.physics)for(let n in t.physics){let e=t.physics[n],i=-1;if(n.length>0){let t=s.findPhysicsConstraint(n);if(!t)throw new Error("Physics constraint not found: "+n);i=s.physicsConstraints.indexOf(t)}for(let t in e){let s=e[t],r=s[0];if(!r)continue;let n,o=s.length;if("reset"==t){const t=new Wt(o,i);for(let e=0;null!=r;r=s[e+1],e++)t.setFrame(e,Js(r,"time",0));a.push(t);continue}if("inertia"==t)n=new Bt(o,o,i);else if("strength"==t)n=new Vt(o,o,i);else if("damping"==t)n=new Dt(o,o,i);else if("mass"==t)n=new _t(o,o,i);else if("wind"==t)n=new Nt(o,o,i);else if("gravity"==t)n=new Ot(o,o,i);else{if("mix"!=t)continue;n=new Lt(o,o,i)}a.push(Hs(s,n,0,1))}}if(t.attachments)for(let n in t.attachments){let e=t.attachments[n],r=s.findSkin(n);if(!r)throw new Error("Skin not found: "+n);for(let t in e){let n=e[t],o=s.findSlot(t);if(!o)throw new Error("Slot not found: "+t);let l=o.index;for(let t in n){let e=n[t],s=r.getAttachment(l,t);for(let t in e){let r=e[t],n=r[0];if(n)if("deform"==t){let t=s.bones,e=s.vertices,o=t?e.length/3*2:e.length,h=new St(r.length,r.length,l,s),c=Js(n,"time",0);for(let s=0,a=0;;s++){let l,d=Js(n,"vertices",null);if(d){l=O.newFloatArray(o);let s=Js(n,"offset",0);if(O.arrayCopy(d,0,l,s,d.length),1!=i)for(let t=s,e=t+d.length;t<e;t++)l[t]*=i;if(!t)for(let t=0;t<o;t++)l[t]+=e[t]}else l=t?O.newFloatArray(o):e;h.setFrame(s,c,l);let u=r[s+1];if(!u){h.shrink(a);break}let m=Js(u,"time",0),f=n.curve;f&&(a=Qs(f,h,a,s,0,c,m,0,1,1)),c=m,n=u}a.push(h)}else if("sequence"==t){let t=new zt(r.length,l,s),e=0;for(let s=0;s<r.length;s++){let i=Js(n,"delay",e),a=Js(n,"time",0),o=$[Js(n,"mode","hold")],l=Js(n,"index",0);t.setFrame(s,a,o,l,i),e=i,n=r[s+1]}a.push(t)}}}}}if(t.drawOrder){let e=new Ft(t.drawOrder.length),i=s.slots.length,r=0;for(let a=0;a<t.drawOrder.length;a++,r++){let n=t.drawOrder[a],o=null,l=Js(n,"offsets",null);if(l){o=O.newArray(i,-1);let t=O.newArray(i-l.length,0),e=0,a=0;for(let i=0;i<l.length;i++){let r=l[i],n=s.findSlot(r.slot);if(!n)throw new Error("Slot not found: "+n);let h=n.index;for(;e!=h;)t[a++]=e++;o[e+r.offset]=e++}for(;e<i;)t[a++]=e++;for(let s=i-1;s>=0;s--)-1==o[s]&&(o[s]=t[--a])}e.setFrame(r,Js(n,"time",0),o)}a.push(e)}if(t.events){let e=new Ct(t.events.length),i=0;for(let a=0;a<t.events.length;a++,i++){let r=t.events[a],n=s.findEvent(r.name);if(!n)throw new Error("Event not found: "+r.name);let o=new Be(O.toSinglePrecision(Js(r,"time",0)),n);o.intValue=Js(r,"int",n.intValue),o.floatValue=Js(r,"float",n.floatValue),o.stringValue=Js(r,"string",n.stringValue),o.data.audioPath&&(o.volume=Js(r,"volume",1),o.balance=Js(r,"balance",0)),e.setFrame(i,o)}a.push(e)}let r=0;for(let n=0,o=a.length;n<o;n++)r=Math.max(r,a[n].getDuration());s.animations.push(new Q(e,a,r))}}class $s{constructor(t,s,i,a,r){e(this,"parent"),e(this,"skin"),e(this,"slotIndex"),e(this,"mesh"),e(this,"inheritTimeline"),this.mesh=t,this.skin=s,this.slotIndex=i,this.parent=a,this.inheritTimeline=r}}function Hs(t,e,s,i){let a=t[0],r=Js(a,"time",0),n=Js(a,"value",s)*i,o=0;for(let l=0;;l++){e.setFrame(l,r,n);let h=t[l+1];if(!h)return e.shrink(o),e;let c=Js(h,"time",0),d=Js(h,"value",s)*i;a.curve&&(o=Qs(a.curve,e,o,l,0,r,c,n,d,i)),r=c,n=d,a=h}}function Ks(t,e,s,i,a,r){let n=t[0],o=Js(n,"time",0),l=Js(n,s,a)*r,h=Js(n,i,a)*r,c=0;for(let d=0;;d++){e.setFrame(d,o,l,h);let u=t[d+1];if(!u)return e.shrink(c),e;let m=Js(u,"time",0),f=Js(u,s,a)*r,g=Js(u,i,a)*r,p=n.curve;p&&(c=Qs(p,e,c,d,0,o,m,l,f,r),c=Qs(p,e,c,d,1,o,m,h,g,r)),o=m,l=f,h=g,n=u}}function Qs(t,e,s,i,a,r,n,o,l,h){if("stepped"==t)return e.setStepped(i),s;let c=a<<2,d=t[c],u=t[c+1]*h,m=t[c+2],f=t[c+3]*h;return e.setBezier(s,i,a,r,o,d,u,m,f,n,l),s+1}function Js(t,e,s){return void 0!==t[e]?t[e]:s}void 0===Math.fround&&(Math.fround=function(t){return function(e){return t[0]=e,t[0]}}(new Float32Array(1)));const Zs=class t extends le{constructor(t){super(t.resource),e(this,"texture"),this.texture=s.from(t)}static from(e){return t.textureMap.has(e)?t.textureMap.get(e):new t(e)}setFilters(e,s){const i=this.texture.source.style;i.minFilter=t.toPixiTextureFilter(e),i.magFilter=t.toPixiTextureFilter(s),this.texture.source.autoGenerateMipmaps=t.toPixiMipMap(e),this.texture.source.updateMipmaps()}setWraps(e,s){const i=this.texture.source.style;i.addressModeU=t.toPixiTextureWrap(e),i.addressModeV=t.toPixiTextureWrap(s)}dispose(){this.texture.destroy()}static toPixiMipMap(t){switch(t){case he.Nearest:case he.Linear:return!1;case he.MipMapNearestLinear:case he.MipMapNearestNearest:case he.MipMapLinearLinear:case he.MipMapLinearNearest:return!0;default:throw new Error(`Unknown texture filter: ${String(t)}`)}}static toPixiTextureFilter(t){switch(t){case he.Nearest:case he.MipMapNearestLinear:case he.MipMapNearestNearest:return"nearest";case he.Linear:case he.MipMapLinearLinear:case he.MipMapLinearNearest:return"linear";default:throw new Error(`Unknown texture filter: ${String(t)}`)}}static toPixiTextureWrap(t){switch(t){case de.ClampToEdge:return"clamp-to-edge";case de.MirroredRepeat:return"mirror-repeat";case de.Repeat:return"repeat";default:throw new Error(`Unknown texture wrap: ${String(t)}`)}}static toPixiBlending(t){switch(t){case He.Normal:return"normal";case He.Additive:return"add";case He.Multiply:return"multiply";case He.Screen:return"screen";default:throw new Error(`Unknown blendMode: ${String(t)}`)}}};e(Zs,"textureMap",new Map);let ti=Zs;const ei="spineTextureAtlasLoader",si={extension:a.Asset,resolver:{test:t=>n(t,".atlas"),parse:t=>{const e=t.split(".");return{resolution:parseFloat(d.RETINA_PREFIX?.exec(t)?.[1]??"1"),format:e[e.length-2],src:t}}},loader:{id:ei,name:ei,extension:{type:a.LoadParser,priority:i.Normal,name:ei},test:t=>n(t,".atlas"),async load(t){const e=await c.get().fetch(t);return await e.text()},testParse(t,e){const s=n(e.src,".atlas"),i="string"==typeof t,a=e.parser===ei||e.loadParser===ei;return Promise.resolve((s||a)&&i)},unload(t){t.dispose()},async parse(t,e,s){const i=e.data||{};let a=o.dirname(e.src);a&&a.lastIndexOf("/")!==a.length-1&&(a+="/");const r=new fe(t);if(i.images instanceof l||"string"==typeof i.images){const t=i.images;i.images={},i.images[r.pages[0].name]=t}const n=[];for(const c of r.pages){const t=c.name,r=i?.images?i.images[t]:void 0;if(r instanceof l)c.setTexture(ti.from(r));else{const l=r??o.normalize([...a.split(o.sep),t].join(o.sep)),d={src:h(l,e.src),data:{...i.imageMetadata,alphaMode:c.pma?"premultiplied-alpha":"premultiply-alpha-on-upload"}},u=s.load(d).then(t=>{c.setTexture(ti.from(t.source))});n.push(u)}}return await Promise.all(n),r}}};r.add(si);const ii="spineSkeletonLoader";const ai={extension:a.Asset,loader:{id:ii,name:ii,extension:{type:a.LoadParser,priority:i.Normal,name:ii},test:t=>n(t,".skel"),async load(t){const e=await c.get().fetch(t);return new Uint8Array(await e.arrayBuffer())},testParse(t,e){const s=n(e.src,".json")&&(i=t,Object.prototype.hasOwnProperty.call(i,"bones"));var i;const a=n(e.src,".skel")&&function(t){return t instanceof Uint8Array}(t),r=e.parser===ii||e.loadParser===ii;return Promise.resolve(s||a||r)}}};r.add(ai);const ri=new Float32Array(1),ni=new Uint32Array(1);class oi extends u{constructor(){const t=new m({data:ri,label:"attribute-batch-buffer",usage:f.VERTEX|f.COPY_DST,shrinkToFit:!1});super({attributes:{aPosition:{buffer:t,format:"float32x2",stride:28,offset:0},aUV:{buffer:t,format:"float32x2",stride:28,offset:8},aColor:{buffer:t,format:"unorm8x4",stride:28,offset:16},aDarkColor:{buffer:t,format:"unorm8x4",stride:28,offset:20},aTextureIdAndRound:{buffer:t,format:"uint16x2",stride:28,offset:24}},indexBuffer:new m({data:ni,label:"index-batch-buffer",usage:f.INDEX|f.COPY_DST,shrinkToFit:!1})})}}const li={name:"color-bit",vertex:{header:"\n            @in aDarkColor: vec4<f32>;\n            @out vDarkColor: vec4<f32>;\n        ",main:"\n        vDarkColor = aDarkColor;\n        "},fragment:{header:"\n            @in vDarkColor: vec4<f32>;\n        ",end:"\n\n        let alpha = outColor.a * vColor.a;\n        let rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;\n\n        finalColor = vec4<f32>(rgb, alpha);\n\n        "}},hi={name:"color-bit",vertex:{header:"\n            in vec4 aDarkColor;\n            out vec4 vDarkColor;\n        ",main:"\n            vDarkColor = aDarkColor;\n        "},fragment:{header:"\n            in vec4 vDarkColor;\n        ",end:"\n\n        finalColor.a = outColor.a * vColor.a;\n        finalColor.rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;\n        "}};class ci extends g{constructor(t){super({glProgram:p({name:"dark-tint-batch",bits:[b,hi,x(t),w]}),gpuProgram:y({name:"dark-tint-batch",bits:[k,li,v(t),A]}),resources:{batchSamplers:S(t)}})}}let di=null;const ui=class t extends I{constructor(){super(...arguments),e(this,"geometry",new oi),e(this,"shader",di||(di=new ci(this.maxTextures))),e(this,"name",t.extension.name),e(this,"vertexSize",7)}packAttributes(t,e,s,i,a){const r=a<<16|65535&t.roundPixels,n=t.transform,o=n.a,l=n.b,h=n.c,c=n.d,d=n.tx,u=n.ty,{positions:m,uvs:f}=t,g=t.color,p=(g>>24&255)/255,b=C.shared.setValue(t.darkColor).premultiply(p,!0).toPremultiplied(1,!1),x=t.attributeOffset,w=x+t.attributeSize;for(let y=x;y<w;y++){const t=2*y,a=m[t],n=m[t+1];e[i++]=o*a+h*n+d,e[i++]=c*n+l*a+u,e[i++]=f[t],e[i++]=f[t+1],s[i++]=g,s[i++]=b,s[i++]=r}}packQuadAttributes(t,e,s,i,a){const r=t.texture,n=t.transform,o=n.a,l=n.b,h=n.c,c=n.d,d=n.tx,u=n.ty,m=t.bounds,f=m.maxX,g=m.minX,p=m.maxY,b=m.minY,x=r.uvs,w=t.color,y=t.darkColor,k=a<<16|65535&t.roundPixels;e[i+0]=o*g+h*b+d,e[i+1]=c*b+l*g+u,e[i+2]=x.x0,e[i+3]=x.y0,s[i+4]=w,s[i+5]=y,s[i+6]=k,e[i+7]=o*f+h*b+d,e[i+8]=c*b+l*f+u,e[i+9]=x.x1,e[i+10]=x.y1,s[i+11]=w,s[i+12]=y,s[i+13]=k,e[i+14]=o*f+h*p+d,e[i+15]=c*p+l*f+u,e[i+16]=x.x2,e[i+17]=x.y2,s[i+18]=w,s[i+19]=y,s[i+20]=k,e[i+21]=o*g+h*p+d,e[i+22]=c*p+l*g+u,e[i+23]=x.x3,e[i+24]=x.y3,s[i+25]=w,s[i+26]=y,s[i+27]=k}};e(ui,"extension",{type:[a.Batcher],name:"darkTint"});let mi=ui;r.add(mi);class fi{constructor(){e(this,"indexOffset",0),e(this,"attributeOffset",0),e(this,"indexSize"),e(this,"attributeSize"),e(this,"batcherName","darkTint"),e(this,"topology","triangle-list"),e(this,"packAsQuad",!1),e(this,"renderable"),e(this,"positions"),e(this,"indices"),e(this,"uvs"),e(this,"roundPixels"),e(this,"data"),e(this,"blendMode"),e(this,"darkTint"),e(this,"texture"),e(this,"transform"),e(this,"_textureId"),e(this,"_attributeStart"),e(this,"_indexStart"),e(this,"_batcher"),e(this,"_batch")}get color(){const t=this.data.color,e=this.renderable.groupColor,s=this.renderable.groupAlpha;let i;const a=t.a*s*255;if(16777215!==e){const s=e>>16&255,r=e>>8&255,n=255&e,o=t.r*n,l=t.g*r;i=a<<24|t.b*s<<16|l<<8|o}else i=a<<24|255*t.b<<16|255*t.g<<8|255*t.r;return i}get darkColor(){const t=this.data.darkColor;return 255*t.b<<16|255*t.g<<8|255*t.r}get groupTransform(){return this.renderable.groupTransform}setData(t,e,s,i){if(this.renderable=t,this.transform=t.groupTransform,this.data=e,e.clipped){const t=e.clippedData;this.indexSize=t.indicesCount,this.attributeSize=t.vertexCount,this.positions=t.vertices,this.indices=t.indices,this.uvs=t.uvs}else this.indexSize=e.indices.length,this.attributeSize=e.vertices.length/2,this.positions=e.vertices,this.indices=e.indices,this.uvs=e.uvs;this.texture=e.texture,this.roundPixels=i,this.blendMode=s,this.batcherName=e.darkTint?"darkTint":"default"}}const gi={0:"normal",1:"add",2:"multiply",3:"screen"};class pi{constructor(t){e(this,"renderer"),e(this,"gpuSpineData",{}),e(this,"_destroyRenderableBound",this.destroyRenderable.bind(this)),this.renderer=t}validateRenderable(t){if(t._validateAndTransformAttachments(),t.spineAttachmentsDirty)return!0;if(t.spineTexturesDirty){const e=t.skeleton.drawOrder,s=this.gpuSpineData[t.uid];for(let i=0,a=e.length;i<a;i++){const a=e[i],r=a.getAttachment();if(r instanceof ve||r instanceof xe){const e=t._getCachedData(a,r),i=s.slotBatches[e.id],n=e.texture;if(n!==i.texture&&!i._batcher.checkAndUpdateTexture(i,n))return!0}}}return!1}addRenderable(t,e){var s,i;const a=this._getSpineData(t),r=this.renderer.renderPipes.batch,n=t.skeleton.drawOrder,o=this.renderer._roundPixels|t._roundPixels;t._validateAndTransformAttachments(),t.spineAttachmentsDirty=!1,t.spineTexturesDirty=!1;for(let l=0,h=n.length;l<h;l++){const h=n[l],c=h.getAttachment(),d=gi[h.data.blendMode];let u=!1;if(c instanceof ve||c instanceof xe){const n=t._getCachedData(h,c),l=(s=a.slotBatches)[i=n.id]||(s[i]=new fi);l.setData(t,n,d,o),u=n.skipRender,u||r.addToBatch(l,e)}const m=t._slotsObject[h.data.name];if(m){const t=m.container;u||(t.includeInBuild=!0,t.collectRenderables(e,this.renderer,null)),t.includeInBuild=!1}}}updateRenderable(t){const e=this.gpuSpineData[t.uid];t._validateAndTransformAttachments(),t.spineAttachmentsDirty=!1,t.spineTexturesDirty=!1;const s=t.skeleton.drawOrder;for(let i=0,a=s.length;i<a;i++){const a=s[i],r=a.getAttachment();if(r instanceof ve||r instanceof xe){if(!t._getCachedData(a,r).skipRender){const s=e.slotBatches[t._getCachedData(a,r).id];s._batcher?.updateElement(s)}}}}destroyRenderable(t){this.gpuSpineData[t.uid]=null,t.off("destroyed",this._destroyRenderableBound)}destroy(){this.gpuSpineData=null,this.renderer=null}_getSpineData(t){return this.gpuSpineData[t.uid]||this._initMeshData(t)}_initMeshData(t){return this.gpuSpineData[t.uid]={slotBatches:{}},t.on("destroyed",this._destroyRenderableBound),this.gpuSpineData[t.uid]}}e(pi,"extension",{type:[a.WebGLPipes,a.WebGPUPipes,a.CanvasPipes],name:"spine"}),r.add(pi);const bi=new q;je.yDown=!0;const xi=new js,wi=new L(()=>new P);class yi extends M{constructor(t){t instanceof Je&&(t={skeletonData:t}),super({}),e(this,"batched",!0),e(this,"buildId",0),e(this,"renderPipeId","spine"),e(this,"_didSpineUpdate",!1),e(this,"beforeUpdateWorldTransforms",()=>{}),e(this,"afterUpdateWorldTransforms",()=>{}),e(this,"skeleton"),e(this,"state"),e(this,"skeletonBounds"),e(this,"darkTint",!1),e(this,"_debug"),e(this,"_slotsObject",Object.create(null)),e(this,"clippingSlotToPixiMasks",Object.create(null)),e(this,"spineAttachmentsDirty",!0),e(this,"spineTexturesDirty",!0),e(this,"_lastAttachments",[]),e(this,"_stateChanged",!0),e(this,"attachmentCacheData",[]),e(this,"_autoUpdate",!1),e(this,"_boundsProvider"),e(this,"hasNeverUpdated",!0),e(this,"currentClippingSlot"),this.allowChildren=!0;const s=t instanceof Je?t:t.skeletonData;this.skeleton=new je(s),this.state=new Gt(new re(s)),this.autoUpdate=t?.autoUpdate??!0,this.darkTint=void 0===t?.darkTint?this.skeleton.slots.some(t=>!!t.data.darkColor):t?.darkTint;const i=this.skeleton.slots;for(let e=0;e<i.length;e++)this.attachmentCacheData[e]=Object.create(null);this._boundsProvider=t.boundsProvider}getSlotFromRef(t){let e;if(e="number"==typeof t?this.skeleton.slots[t]:"string"==typeof t?this.skeleton.findSlot(t):t,!e)throw new Error(`No slot found with the given slot reference: ${t}`);return e}get debug(){return this._debug}set debug(t){this._debug&&this._debug.unregisterSpine(this),t&&t.registerSpine(this),this._debug=t}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t&&!this._autoUpdate?F.shared.add(this.internalUpdate,this):!t&&this._autoUpdate&&F.shared.remove(this.internalUpdate,this),this._autoUpdate=t}get boundsProvider(){return this._boundsProvider}set boundsProvider(t){this._boundsProvider=t,t&&(this._boundsDirty=!1),this.updateBounds()}update(t){this.internalUpdate(0,t)}internalUpdate(t,e){this._updateAndApplyState(e??F.shared.deltaMS/1e3)}get bounds(){return this._boundsDirty&&this.updateBounds(),this._bounds}setBonePosition(t,e){const s=t;if("string"==typeof t&&(t=this.skeleton.findBone(t)),!t)throw Error(`Cant set bone position, bone ${String(s)} not found`);if(bi.set(e.x,e.y),t.parent){const e=t.parent.worldToLocal(bi);t.x=e.x,t.y=-e.y}else t.x=bi.x,t.y=bi.y}getBonePosition(t,e){const s=t;return"string"==typeof t&&(t=this.skeleton.findBone(t)),t?(e||(e={x:0,y:0}),e.x=t.worldX,e.y=t.worldY,e):(console.error(`Cant set bone position! Bone ${String(s)} not found`),e)}_updateAndApplyState(t){this.hasNeverUpdated=!1,this.state.update(t),this.skeleton.update(t);const{skeleton:e}=this;this.state.apply(e),this.beforeUpdateWorldTransforms(this),e.updateWorldTransform(Ge.update),this.afterUpdateWorldTransforms(this),this.updateSlotObjects(),this._stateChanged=!0,this.onViewUpdate()}_validateAndTransformAttachments(){this._stateChanged&&(this._stateChanged=!1,this.validateAttachments(),this.transformAttachments())}validateAttachments(){const t=this.skeleton.drawOrder,e=this._lastAttachments;let s=0,i=!1;for(let a=0;a<t.length;a++){const r=t[a].getAttachment();r&&(r!==e[s]&&(i=!0,e[s]=r),s++)}s!==e.length&&(i=!0,e.length=s),this.spineAttachmentsDirty||(this.spineAttachmentsDirty=i)}updateAndSetPixiMask(t,e){var s,i;const a=t.attachment;if(a&&a instanceof oe){const e=(s=this.clippingSlotToPixiMasks)[i=t.data.name]||(s[i]={slot:t,vertices:new Array});return e.maskComputed=!1,void(this.currentClippingSlot=e)}let r=this.currentClippingSlot,n=this._slotsObject[t.data.name];if(r&&n){let t=r.mask;if(t||(t=wi.obtain(),r.mask=t,this.addChild(t)),!r.maskComputed){let e=r.slot,s=e.attachment;r.maskComputed=!0;const i=s.worldVerticesLength,a=r.vertices;s.computeWorldVertices(e,0,i,a,0,2),t.clear().poly(a).stroke({width:0}).fill({alpha:.25})}n.container.mask=t}else n?.container.mask&&(n.container.mask=null);if(r&&r.slot.attachment.endSlot==t.data&&(this.currentClippingSlot=void 0),e){for(const t in this.clippingSlotToPixiMasks){const e=this.clippingSlotToPixiMasks[t];e.slot.attachment instanceof oe&&e.maskComputed||!e.mask||(this.removeChild(e.mask),wi.free(e.mask),e.mask=void 0)}this.currentClippingSlot=void 0}}transformAttachments(){const t=this.skeleton.drawOrder;for(let e=0;e<t.length;e++){const i=t[e];this.updateAndSetPixiMask(i,e===t.length-1);const a=i.getAttachment();if(a)if(a instanceof xe||a instanceof ve){const t=this._getCachedData(i,a);a instanceof ve?a.computeWorldVertices(i,t.vertices,0,2):a.computeWorldVertices(i,0,a.worldVerticesLength,t.vertices,0,2),t.uvs.length<a.uvs.length&&(t.uvs=new Float32Array(a.uvs.length)),Y(a.uvs.buffer,t.uvs.buffer);const e=i.bone.skeleton.color,r=i.color,n=a.color,o=e.a*r.a*n.a;if(t.color.set(e.r*r.r*n.r,e.g*r.g*n.g,e.b*r.b*n.b,o),0===this.alpha||0===o)t.skipRender||(this.spineAttachmentsDirty=!0),t.skipRender=!0;else{t.skipRender&&(this.spineAttachmentsDirty=!0),t.skipRender=t.clipped=!1,i.darkColor&&t.darkColor.setFromColor(i.darkColor);const e=a.region?.texture.texture||s.EMPTY;t.texture!==e&&(t.texture=e,this.spineTexturesDirty=!0),xi.isClipping()&&this.updateClippingData(t)}}else if(a instanceof oe){xi.clipStart(i,a);continue}xi.clipEndWithSlot(i)}xi.clipEnd()}updateClippingData(t){t.clipped=!0,xi.clipTrianglesUnpacked(t.vertices,t.indices,t.indices.length,t.uvs);const{clippedVertices:e,clippedUVs:s,clippedTriangles:i}=xi,a=e.length/2,r=i.length;t.clippedData||(t.clippedData={vertices:new Float32Array(2*a),uvs:new Float32Array(2*a),vertexCount:a,indices:new Uint16Array(r),indicesCount:r},this.spineAttachmentsDirty=!0);const n=t.clippedData,o=n.vertexCount!==a||r!==n.indicesCount;t.skipRender=0===a,o&&(this.spineAttachmentsDirty=!0,n.vertexCount<a&&(n.vertices=new Float32Array(2*a),n.uvs=new Float32Array(2*a)),n.indices.length<r&&(n.indices=new Uint16Array(r)));const{vertices:l,uvs:h,indices:c}=n;for(let d=0;d<a;d++)l[2*d]=e[2*d],l[2*d+1]=e[2*d+1],h[2*d]=s[2*d],h[2*d+1]=s[2*d+1];n.vertexCount=a;for(let d=0;d<r;d++)c[d]!==i[d]&&(this.spineAttachmentsDirty=!0,c[d]=i[d]);n.indicesCount=r}updateSlotObjects(){for(const t in this._slotsObject){const e=this._slotsObject[t];e&&this.updateSlotObject(e)}}updateSlotObject(t){const{slot:e,container:s}=t,i=!t.followAttachmentTimeline||Boolean(e.attachment);if(s.visible=this.skeleton.drawOrder.includes(e)&&i,s.visible){let t=e.bone;s.position.set(t.worldX,t.worldY),s.angle=t.getWorldRotationX();let i=1,a=1;for(;t;)i*=t.scaleX,a*=t.scaleY,t=t.parent;i<0&&(s.angle-=180),s.scale.set(e.bone.getWorldScaleX()*Math.sign(i),e.bone.getWorldScaleY()*Math.sign(a)),s.alpha=this.skeleton.color.a*e.color.a}}_getCachedData(t,e){return this.attachmentCacheData[t.data.index][e.name]||this.initCachedData(t,e)}initCachedData(t,e){let s;return e instanceof ve?(s=new Float32Array(8),this.attachmentCacheData[t.data.index][e.name]={id:`${t.data.index}-${e.name}`,vertices:s,clipped:!1,indices:[0,1,2,0,2,3],uvs:new Float32Array(e.uvs.length),color:new V(1,1,1,1),darkColor:new V(0,0,0,0),darkTint:this.darkTint,skipRender:!1,texture:e.region?.texture.texture}):(s=new Float32Array(e.worldVerticesLength),this.attachmentCacheData[t.data.index][e.name]={id:`${t.data.index}-${e.name}`,vertices:s,clipped:!1,indices:e.triangles,uvs:new Float32Array(e.uvs.length),color:new V(1,1,1,1),darkColor:new V(0,0,0,0),darkTint:this.darkTint,skipRender:!1,texture:e.region?.texture.texture}),this.attachmentCacheData[t.data.index][e.name]}onViewUpdate(){if(this._didViewChangeTick++,this._boundsProvider||(this._boundsDirty=!0),this.didViewUpdate)return;this.didViewUpdate=!0;const t=this.renderGroup||this.parentRenderGroup;t&&t.onChildViewUpdate(this),this.debug?.renderDebug(this)}addSlotObject(t,e,s){t=this.getSlotFromRef(t);for(const a in this._slotsObject)this._slotsObject[a]?.container===e&&this.removeSlotObject(this._slotsObject[a].slot);this.removeSlotObject(t),e.includeInBuild=!1,this.addChild(e);const i={container:e,slot:t,followAttachmentTimeline:s?.followAttachmentTimeline||!1};this._slotsObject[t.data.name]=i,this.updateSlotObject(i)}removeSlotObject(t){let e;if(t instanceof T){for(const s in this._slotsObject)if(this._slotsObject[s]?.container===t){this._slotsObject[s]=null,e=t;break}}else{const s=this.getSlotFromRef(t);e=this._slotsObject[s.data.name]?.container,this._slotsObject[s.data.name]=null}e&&(this.removeChild(e),e.includeInBuild=!0)}removeSlotObjects(){Object.entries(this._slotsObject).forEach(([t,e])=>{e&&e.container.removeFromParent(),delete this._slotsObject[t]})}getSlotObject(t){return t=this.getSlotFromRef(t),this._slotsObject[t.data.name]?.container}updateBounds(){this._boundsDirty=!1,this.skeletonBounds||(this.skeletonBounds=new Us);const t=this.skeletonBounds;if(t.update(this.skeleton,!0),this._boundsProvider){const t=this._boundsProvider.calculateBounds(this),e=this._bounds;e.clear(),e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height}else if(t.minX===1/0){this.hasNeverUpdated&&(this._updateAndApplyState(0),this._boundsDirty=!1),this._validateAndTransformAttachments();const t=this.skeleton.drawOrder,e=this._bounds;e.clear();for(let s=0;s<t.length;s++){const i=t[s],a=i.getAttachment();if(a&&(a instanceof ve||a instanceof xe)){const t=this._getCachedData(i,a);e.addVertexData(t.vertices,0,t.vertices.length)}}}else this._bounds.minX=t.minX,this._bounds.minY=t.minY,this._bounds.maxX=t.maxX,this._bounds.maxY=t.maxY}addBounds(t){t.addBounds(this.bounds)}destroy(t=!1){super.destroy(t),F.shared.remove(this.internalUpdate,this),this.state.clearListeners(),this.debug=void 0,this.skeleton=null,this.state=null,this._slotsObject=null,this._lastAttachments.length=0,this.attachmentCacheData=null}skeletonToPixiWorldCoordinates(t){this.worldTransform.apply(t,t)}pixiWorldCoordinatesToSkeleton(t){this.worldTransform.applyInverse(t,t)}pixiWorldCoordinatesToBone(t,e){this.pixiWorldCoordinatesToSkeleton(t),e.parent?e.parent.worldToLocal(t):e.worldToLocal(t)}static from({skeleton:t,atlas:e,scale:s=1,darkTint:i,autoUpdate:a=!0,boundsProvider:r}){const n=`${t}-${e}-${s}`;if(X.has(n))return new yi({skeletonData:X.get(n),darkTint:i,autoUpdate:a,boundsProvider:r});const o=R.get(t),l=R.get(e),h=new Ae(l),c=o instanceof Uint8Array?new is(h):new Gs(h);c.scale=s;const d=c.readSkeletonData(o);return X.set(n,d),new yi({skeletonData:d,darkTint:i,autoUpdate:a,boundsProvider:r})}}export{yi as S};
